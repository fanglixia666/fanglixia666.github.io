<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java（封装）（构造器）（继承）（多态性） | 方立夏</title>
  <meta name="keywords" content=" Github , Java ">
  <meta name="description" content="Java（封装）（构造器）（继承）（多态性） | 方立夏">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="算法学习（2023 -03-09）（数组）涉及到的算法题目1.2.3题涉及的知识点为滑动窗口1.长度最小的子数组1.题目给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 解释：子数组 [">
<meta property="og:type" content="article">
<meta property="og:title" content="算法练习（数组滑动窗口）">
<meta property="og:url" content="http://example.com/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A03%EF%BC%88%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%9A%84%E5%89%A9%E4%BD%99%E7%9F%A5%E8%AF%86%EF%BC%89/index.html">
<meta property="og:site_name" content="方立夏">
<meta property="og:description" content="算法学习（2023 -03-09）（数组）涉及到的算法题目1.2.3题涉及的知识点为滑动窗口1.长度最小的子数组1.题目给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 解释：子数组 [">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210312160441942.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCicvQicWSnN5ZNP97xQibk5RenSvNNZpr8ibMzLDeC2apV3ia2XS7ibTLC5WgGn3VStmCTw6elicia0ht2v6g/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBCcaan5hg7GsqSCVwq4sgZHyqBqfFF4G4oTjhACibCp2RcuMEPeHVjKQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBRn0NZibJkWiaJ522aMDOQEsiaiaX4AuXIBEjjKqetvibL104qGfSvmU4BRg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBECDRbicfLRcRFCERDN4Ykq56ILvDlh6bft5nzG5TqgFXw4ib4y4kw4OA/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBcBzAWFuJjRttCghicyKua5cXicG1db1nTj3QLUh4nXgBNVkp2gznOzdw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBHI2kPictZLyUeWXQ9Q6N5WBzRlBEXLRewuCDnmL4F2YiaPDN20w2ib9OQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBvib02FtjqhSI1R4CQVan160CwemYBsuofXycNecXWJIdysfwBeL2HibQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBbdTCtSzibQCt2O6kXkY18e5cncbriaPmjVDia5jp7rgFXICOoQPLBRIDA/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBS9aOEoYGMaic9SBZ2RoRx7soNExMKFbP3NsVo7aicKBjqz0iae46vATRg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBGttfPK4icjwqxIOHdXC0xoMBLsG173oEN1KTlCmxGvN360XPiciaqvzIg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBGAM79Tu8Xz5PX4C7Ub0oYFfUiaWU9qnrAXBmJZWPM8gGCloPaUqBwicQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBWDzzNiamIibl3YACnJyz1mgAnHwuTcteHOXpIXO5icph9rQAMxWTg4e7A/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBfwZocA61fXZPC26uuNKMUsk062VgbicxcLibf5tTQt2Uf6seEBYuZNlQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBtxrnKCicDoKEz5KvUAp4YIzA0W9d66xLK3z1HCpoVD5n1cXJUEnLvvQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBUQlq7WcBBpNfnz7OhuFtl72dMsNHstTiaD1icZCMO7ibFoxfkRun7aorg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBwoNdbBfnQbibPDibLpmyCKZ5XIpzUbjtgDaR86xUBFWDFGTgKPibGZcjw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSB5q9L67xuHKkWq8aGMsAOGty4Eybu1wicNicQmiajtCplAPNzxHicQggnyw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBfMaWjJSOIdunBicib5lB9TImdvGUgJQoibouvvl7dIRIL6CztXY0tBDoQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png">
<meta property="article:published_time" content="2023-03-21T07:31:11.887Z">
<meta property="article:modified_time" content="2023-03-21T07:28:51.314Z">
<meta property="article:author" content="方立夏">
<meta property="article:tag" content="java">
<meta property="article:tag" content="Github">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/github.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>方立夏</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/fanglixia666"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:2377579176@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2377579176&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(9)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="博客篇">
                        
                        博客篇
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="后端篇">
                        
                        后端篇
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法篇">
                        
                        算法篇
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="9">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A03%EF%BC%88%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%9A%84%E5%89%A9%E4%BD%99%E7%9F%A5%E8%AF%86%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（数组滑动窗口）">算法练习（数组滑动窗口）</span>
            <span class="post-date" title="2023-03-21 15:31:11">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（数组）">算法练习（数组）</span>
            <span class="post-date" title="2023-03-21 15:31:10">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8923-03-10/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（哈希表）">算法练习（哈希表）</span>
            <span class="post-date" title="2023-03-21 15:31:08">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 后端篇 "
           href="/2023/03/21/Java%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%B1%BB%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="Java高级篇（异常，多线程，常用类）">Java高级篇（异常，多线程，常用类）</span>
            <span class="post-date" title="2023-03-21 15:30:59">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 后端篇 "
           href="/2023/03/21/Java%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%8C%20%E6%B3%9B%E6%80%A7%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="Java HashMap 方法">Java HashMap 方法</span>
            <span class="post-date" title="2023-03-21 15:30:57">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A02%E4%B8%80%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（双指针）">算法练习（双指针）</span>
            <span class="post-date" title="2023-03-21 15:25:32">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（字符串）">算法练习（字符串）</span>
            <span class="post-date" title="2023-03-21 15:25:25">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 博客篇 "
           href="/2023/03/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/"
           data-tag="Github,Java"
           data-author="" >
            <span class="post-title" title="Java（封装）（构造器）（继承）（多态性）">Java（封装）（构造器）（继承）（多态性）</span>
            <span class="post-date" title="2023-03-21 10:56:25">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/03/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-03-21 10:51:18">2023/03/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-面向对象1" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java（封装）（构造器）（继承）（多态性）</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="博客篇">博客篇</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">Github</a>
            
            <a class="color5">Java</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-03-27 20:59:08'>2023-03-21 10:56</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11"><span class="toc-text">面向对象1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">1.1类与对象的创建及使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B1%9E%E6%80%A7"><span class="toc-text">1.2类的成员之一：属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%96%B9%E6%B3%95"><span class="toc-text">1.3类的成员之二：方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text">1.4方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-text">1.5方法参数值传递机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E9%80%92%E5%BD%92"><span class="toc-text">1.6递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="toc-text">2.面向对象特征之一：封装与隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2.1四种权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2.2四种访问权限修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%89%EF%BC%89"><span class="toc-text">3.构造器（类的成员之三）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%9E%84%E9%80%A0%E5%99%A8%E7%90%86%E8%A7%A3"><span class="toc-text">3.1构造器理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">3.2属性赋值的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3Javabean"><span class="toc-text">3.3Javabean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-UML%E7%B1%BB%E5%9B%BE"><span class="toc-text">3.4 UML类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85%E7%90%86%E8%A7%A3"><span class="toc-text">3.5关于构造器的一些补充理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-this%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.this的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-this%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">4.1.this调用属性，方法，构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-package%E3%80%81import-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">5.package、import 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1package"><span class="toc-text">5.1package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2import"><span class="toc-text">5.2import</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12"><span class="toc-text">面向对象2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">6.面向对象特征之二：继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">6.1继承性的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="toc-text">6.2继承性的练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-text">7.方法的重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E9%87%8D%E5%86%99%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">7.1重写的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-super"><span class="toc-text">8.super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1super"><span class="toc-text">8.1super</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">9.子类对象实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">10.面向对象特征之三：多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">10.1多态性的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E4%B8%8E%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">10.2向下转型与向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E8%A1%A5%E5%85%85"><span class="toc-text">10.3多态性的补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11object%E7%B1%BB"><span class="toc-text">11object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-text">11.1Object类中的主要结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-x3D-x3D-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8Eequals%E6%96%B9%E6%B3%95"><span class="toc-text">11.2&#x3D;&#x3D;操作符与equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3toString%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">11.3toString的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%8C%85%E8%A3%85%E7%B1%BB-Wrapper-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">12.包装类(Wrapper)的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">12.1单元测试方法的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">12.2包装类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">12.3包装类与基本数据类型相互转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13static"><span class="toc-text">13static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1static%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">13.1static的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%E5%8D%95%E4%BE%8B-Singleton-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">13.2单例(Singleton)设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">14.类的成员之四：代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-final"><span class="toc-text">15.final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">16.抽象类与抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%90%86%E8%A7%A3"><span class="toc-text">16.1抽象类理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BA%94%E7%94%A8"><span class="toc-text">16.2抽象类应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3%E5%88%9B%E5%BB%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">16.3创建抽象类的匿名子类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="toc-text">16.4抽象类的练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%8E%A5%E5%8F%A3"><span class="toc-text">17.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">17.1接口的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="toc-text">17.2接口的练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%94%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">18.类的内部成员之五：内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象1"><a href="#面向对象1" class="headerlink" title="面向对象1"></a>面向对象1</h1><h2 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1.类与对象"></a>1.类与对象</h2><h3 id="1-1类与对象的创建及使用"><a href="#1-1类与对象的创建及使用" class="headerlink" title="1.1类与对象的创建及使用"></a>1.1类与对象的创建及使用</h3><pre><code class="java">/*
 * 一、设计类、其实就是设计类的成员
 * Field = 属性 = 成员变量 = 域、字段
 * Method = (成员)方法 = 函数 
 * 
 * 创建类 = 类的实例化 = 实例化类
 * 
 * 二.类和对象的使用(面向对象思想落地的实现)
 * 1.创建类，设计类的成员
 * 2.创建类的对象
 * 3.通过“对象.属性”或“对象.方法”调用对象的结构
 * 三、如果创建类一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非 static 的)
 * 	  意味着:如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。
 */
//测试类
public class PersonTest &#123;
    public static void main(String[] args) &#123;
        //2.创建 Person 类的对象
        //创建对象语法：类名对象名= new 类名();
        Person p1 = new Person();
        //Scanner scan = new Scanner(System.in);
        
        //调用类的结构：属性、方法
        //调用属性:“对象.属性”
        p1.name = &quot;Tom&quot;;
        p1.age = 25;
        p1.isMale = true;
        System.out.println(p1.name);
        
        //调用方法:“对象.方法”
        p1.eat();
        p1.sleep();
        p1.talk(&quot;chinese&quot;);
        //**********************
        Person p2 = new Person();
        System.out.println(p2.name); //null
        System.out.println(p2.isMale);
        //**********************
        //将 p1 变量保存的对象地址值赋给 p3,导致 p1 和 p3 指向了堆空间中的一个对象实体。
        Person p3 = p1;
        System.out.println(p3.name);
        
        p3.age = 10;
        System.out.println(p1.age); //10
    &#125;
&#125;
/*
 * 类的语法格式：
 * 修饰符 class 类名&#123;
 * 		属性声明;
 * 		方法声明;
 * &#125;
 * 说明：修饰符 public：类可以被任意访问类的正文要用&#123;  &#125;括起来
 */
//1.创建类，设计类的成员
class Person&#123;
    
    //属性:对应类中的成员变量
    String name;
    int age;
    boolean isMale;
    
    //方法:对应类中的成员方法
    public void eat()&#123;
        System.out.println(&quot;吃饭&quot;);
    &#125;
    
    public void sleep()&#123;
        System.out.println(&quot;睡觉&quot;);
    &#125;
    
    public void talk(String language)&#123;
        System.out.println(&quot;人可以说话，使用的是：&quot; + language);
    &#125;
&#125;
</code></pre>
<pre><code class="java">关于创建对象的内存解析理解与举例
Person p1= newPerson();
p1.name = &quot;Tom&quot;;
p1.isMale = true;
Person p2 = new Person();
sysout(p2.name);//null
Person p3 = p1;
p3.age = 10;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e10710c43389ff33e23d546de2ee864a.png"></p>
<p>堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。<br>通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。</p>
<h3 id="1-2类的成员之一：属性"><a href="#1-2类的成员之一：属性" class="headerlink" title="1.2类的成员之一：属性"></a>1.2类的成员之一：属性</h3><pre><code class="Java">/*
 * 类中属性的使用
 * 
 * 属性(成员变量)	vs	局部变量
 * 1.相同点:
 * 		1.1 定义变量的格式:数据类型 变量名 = 变量值
 * 		1.2 先声明，后使用
 * 		1.3 变量都有其对应的作用域
 * 				
 * 2.不同点:
 * 		2.1 在类中声明的位置不同
 * 		属性:直接定义在类的一对&#123;&#125;内
 * 		局部变量:声明在方法内、方法形参、构造器形参、构造器内部的变量
 * 
 * 		2.2 关于权限修饰符的不同
 * 		属性:可以在声明属性时，指明其权限，使用权限修饰符。
 * 			常用的权限修饰符:private、public、缺省、protected
 * 			目前声明属性时，都使用缺省即可。
 * 		局部变量:不可以使用权限修饰符。
 * 
 * 		2.3 默认初始化值的情况:
 * 		属性:类的属性，根据其类型，都有默认初始化值。
 * 			整型(byte、short、int、long):0
 * 			浮点型(float、double):0.0
 * 			字符型(char):0(或‘\u0000’)
 * 			布尔型(boolean):false
 * 
 * 			引用数据类型(类、数组、接口):null
 * 
 * 		局部变量:没有默认初始化值
 * 			意味着:在调用局部变量之前，一定要显式赋值。
 * 			特别地:形参在调用时,赋值即可。例，45 行
 * 
 * 		2.4 在内存中加载的位置，亦各不相同。
 * 		属性:加载到堆空间中(非 static)
 * 		局部变量:加载到栈空间
 */
public class UserTest &#123;
    public static void main(String[] args) &#123;
        User u1 = new User();
        System.out.println(u1.name);
        System.out.println(u1.age);
        System.out.println(u1.isMale);
        
        u1.talk(&quot;俄语&quot;);
    &#125;
&#125;
class User&#123;
    //属性(或成员变量)
    String name;	//不加 private 即为缺省
    public int age;	//不加 public 即为缺省
    boolean isMale;
    
    public void talk(String language)&#123;//language:形参，也是局部变量
        System.out.println(&quot;我们使用&quot; + language + &quot;进行交流。&quot;);
    &#125;
    
    public void eat()&#123;
        String food = &quot;石头饼&quot;;	//石头饼:局部变量
        System.out.println(&quot;北方人喜欢吃:&quot; + food);
    &#125;
&#125;
</code></pre>
<h3 id="1-3类的成员之二：方法"><a href="#1-3类的成员之二：方法" class="headerlink" title="1.3类的成员之二：方法"></a>1.3类的成员之二：方法</h3><pre><code class="java">/*
 * 类中方法的声明和使用
 * 
 * 方法：描述类应该具有的功能。
 * 比如：Math类：sqrt()\random() \...
 *     Scanner类：nextXxx() ...
 *     Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ...
 * 
 * 1.举例：
 * public void eat()&#123;&#125;
 * public void sleep(int hour)&#123;&#125;
 * public String getName()&#123;&#125;
 * public String getNation(String nation)&#123;&#125;
 * 
 * 2. 方法的声明：权限修饰符  返回值类型  方法名(形参列表)&#123;
 * 					方法体
 * 			  &#125;
 *   注意：static、final、abstract 来修饰的方法，后面再讲。
 *   
 * 3. 说明：
 * 		3.1 关于权限修饰符：默认方法的权限修饰符先都使用public
 * 			Java规定的4种权限修饰符：private、public、缺省、protected  --&gt;封装性再细说
 * 
 * 		3.2 返回值类型： 有返回值  vs 没有返回值
 * 			3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用
 *                return关键字来返回指定类型的变量或常量：“return 数据”。
 * 				  如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要
 *               使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。
 * 
 * 			3.2.2 我们定义方法该不该有返回值？
 * 				① 题目要求
 * 				② 凭经验：具体问题具体分析
 * 
 *      3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”
 *      3.4 形参列表:方法名可以声明0个、1个，或多个形参。
 *      	3.4.1 格式:数据类型1 形参1，数据类型2 形参2,...
 *      
 *      	3.4.2 我们定义方法时，该不该定义形参？
 *      		① 题目要求
 *      		② 凭经验，具体问题具体分析
 *      3.5 方法体:方法功能的体现。
 *  4. return关键字的使用：
 *  	1.使用范围:使用在方法体中
 *  	2.作业:① 结束方法
 *  		  ② 针对于有返回值类型的方法，使用&quot;return 数据&quot;方法返回所要的数据。
 *  	3.注意点:return关键字后不可声明执行语句。
 *  5. 方法的使用中，可以调用当前类的属性或方法。
 *  		特殊的:方法A中又调用了方法A:递归方法。
 *  	方法中不能定义其他方法。
 */
public class CustomerTest &#123;
    public static void main(String[] args) &#123;
        
        Customer cust1 = new Customer();
        
        cust1.eat();
        
        //测试形参是否需要设置的问题
//		int[] arr = new int[]&#123;3,4,5,2,5&#125;;
//		cust1.sort();
        
        cust1.sleep(8);
        
    &#125;
&#125;
//客户类
class Customer&#123;
    
    //属性
    String name;
    int age;
    boolean isMale;
    
    //方法
    public void eat()&#123;
        System.out.println(&quot;客户吃饭&quot;);
        return;
        //return后不可以声明表达式
//		System.out.println(&quot;hello&quot;);
    &#125;
    
    public void sleep(int hour)&#123;
        System.out.println(&quot;休息了&quot; + hour + &quot;个小时&quot;);
        
        eat();
//		sleep(10);
    &#125;
    
    public String getName()&#123;
        
        if(age &gt; 18)&#123;
            return name;
            
        &#125;else&#123;
            return &quot;Tom&quot;;
        &#125;
    &#125;
    
    public String getNation(String nation)&#123;
        String info = &quot;我的国籍是：&quot; + nation;
        return info;
    &#125;
    
    //体会形参是否需要设置的问题
//	public void sort(int[] arr)&#123;
//		
//	&#125;
//	public void sort()&#123;
//		int[] arr = new int[]&#123;3,4,5,2,5,63,2,5&#125;;
//		//。。。。
//	&#125;
    
    public void info()&#123;
        //错误的
//		public void swim()&#123;
//			
//		&#125;
        
    &#125;
&#125;
</code></pre>
<h3 id="1-4方法的重载"><a href="#1-4方法的重载" class="headerlink" title="1.4方法的重载"></a>1.4方法的重载</h3><pre><code class="java">/*
 * 方法的重载(overload) loading...
 * 
 * 1.定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
 * 	
 * 		“两同一不同”:同一个类、相同方法名
 * 				  参数列表不同：参数个数不同，参数类型不同
 * 
 * 2.举例:
 * 		Arrays类中重载的sort() / binarySearch()
 * 
 * 3.判断是否重载
 * 		与方法的返回值类型、权限修饰符、形参变量名、方法体都无关。
 * 
 * 4.在通过对象调用方法时，如何确定某一个指定的方法：
 * 		方法名---》参数列表
 */
public class OverLoadTest &#123;
    
    public static void main(String[] args) &#123;
        OverLoadTest test = new OverLoadTest();
        test.getSum(1, 2);	//调用的第一个，输出1
    &#125;

    //如下的四个方法构成了重载
    public void getSum(int i,int j)&#123;
        System.out.println(&quot;1&quot;);
    &#125;
    public void getSum(double d1,double d2)&#123;
        System.out.println(&quot;2&quot;);
    &#125;
    public void getSum(String s,int i)&#123;
        System.out.println(&quot;3&quot;);
    &#125;
    
    public void getSum(int i,String s)&#123;
        
    &#125;
    
    //以下3个是错误的重载
//	public int getSum(int i,int j)&#123;
//		return 0;
//	&#125;
    
//	public void getSum(int m,int n)&#123;
//		
//	&#125;
    
//	private void getSum(int i,int j)&#123;
//		
//	&#125;
&#125;
</code></pre>
<h3 id="1-5方法参数值传递机制"><a href="#1-5方法参数值传递机制" class="headerlink" title="1.5方法参数值传递机制"></a>1.5方法参数值传递机制</h3><pre><code class="java">/*
 * 关于变量的赋值
 * 
 * 	如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
 * 	如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。
 * 
 */
public class ValueTransferTest &#123;

    public static void main(String[] args) &#123;
        
        System.out.println(&quot;**********基本数据类型：***********&quot;);
        int m = 10;
        int n = m;
        
        System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n);
        
        n = 20;
        
        System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n);

        System.out.println(&quot;***********引用数据类型:********&quot;);
        
        Order o1 = new Order();
        o1.orderId = 1001;
        
        Order o2 = o1;	//赋值后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体
        System.out.println(&quot;o1.orderId = &quot; + o1.orderId + &quot;,o2.orderId = &quot; + o2.orderId);
        
        o2.orderId = 1002;
        System.out.println(&quot;o1.orderId = &quot; + o1.orderId + &quot;,o2.orderId = &quot; + o2.orderId);
        
    &#125;
&#125;

class Order&#123;
    int orderId;
&#125;
</code></pre>
<h3 id="1-6递归"><a href="#1-6递归" class="headerlink" title="1.6递归"></a>1.6递归</h3><pre><code class="java">/*
 * 递归方法的使用(了解)
 * 1.递归方法：一个方法体内调用它自身。
 * 2.方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
 * 
 * 3.递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。
 * 
 */
public class RecursionTest &#123;

    public static void main(String[] args) &#123;

        // 例1:计算1-100之间所有自然数的和
        // 方法1:
        int sum = 0;
        for (int i = 1; i &lt;= 100; i++) &#123;
            sum += i;
        &#125;
        System.out.println(&quot;sum = &quot; + sum);

        // 方法2:
        RecursionTest test = new RecursionTest();
        int sum1 = test.getSum(100);
        System.out.println(&quot;sum1 = &quot; + sum1);
    &#125;

    // 例1:计算1-n之间所有自然数的和
    public int getSum(int n) &#123;

        if (n == 1) &#123;
            return 1;
        &#125; else &#123;
            return n + getSum(n - 1);
        &#125;
    &#125;

    // 例2:计算1-n之间所有自然数的乘积
    //归求阶乘(n!)的算法
    public int getSum1(int n) &#123;


        if (n == 1) &#123;
            return 1;
        &#125; else &#123;
            return n * getSum1(n - 1);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="2-面向对象特征之一：封装与隐藏"><a href="#2-面向对象特征之一：封装与隐藏" class="headerlink" title="2.面向对象特征之一：封装与隐藏"></a>2.面向对象特征之一：封装与隐藏</h2><pre><code class="java">/*
 * 面向对象的特征一:封装与隐藏
 * 一、问题的引入：
 *    当我们创建一个类的对象以后，我们可以通过&quot;对象.属性&quot;的方式，对对象的属性进行赋值。这里，赋值操作要受到
 *    属性的数据类型和存储范围的制约。但除此之外，没有其他制约条件。但是，实际问题中，我们往往需要给属性赋值
 *    加入额外限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行条件的添加。比如说，setLegs
 *    同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)
 *    --》此时，针对于属性就体现了封装性。
 *    
 * 二、封装性的体现：
 *    我们将类的属性私有化(private),同时,提供公共的(public)方法来获取(getXxx)和设置(setXxx)
 *    
 *    拓展：封装性的体现：① 如上 ② 单例模式 ③ 不对外暴露的私有方法
 *
 */
public class AnimalTest &#123;

    public static void main(String[] args) &#123;
        Animal a = new Animal();
        a.name = &quot;大黄&quot;;
//		a.age = 1;
//		a.legs = 4;//The field Animal.legs is not visible
        
        a.show();
        
//		a.legs = -4;
//		a.setLegs(6);
        a.setLegs(-6);
        
//		a.legs = -4;//The field Animal.legs is not visible
        a.show();
        
        System.out.println(a.name);
        System.out.println(a.getLegs());
    &#125;
&#125;
class Animal&#123;
    
    String name;
    private int age;
    private int legs; //腿的个数
    
    //对于属性的设置
    public void setLegs(int l)&#123;
        if(l &gt;= 0 &amp;&amp; l % 2 == 0)&#123;
            legs = l;
        &#125;else&#123;
            legs = 0;
        &#125;
    &#125;
    
    //对于属性的获取
    public int getLegs()&#123;
        return legs;
    &#125;
    
    public void eat()&#123;
        System.out.println(&quot;动物进食&quot;);
    &#125;
    
    public void show()&#123;
        System.out.println(&quot;name = &quot; + name + &quot;,age = &quot; + age + &quot;,legs = &quot; + legs);
    &#125;
    
    //提供关于属性 age 的 get 和 set 方法
    public int getAge()&#123;
        return age;
    &#125;
    
    public void setAge(int a)&#123;
        age = a;
    &#125;
&#125;
</code></pre>
<h3 id="2-1四种权限修饰符"><a href="#2-1四种权限修饰符" class="headerlink" title="2.1四种权限修饰符"></a>2.1四种权限修饰符</h3><p>Java 权限修饰符<code>public、protected、default(缺省)、private</code> 置于类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ab992b12ef5b16774376e00dab0415e0.png"></p>
<p><strong>对于 class 的权限修饰只可以用 public 和 default(缺省)。</strong></p>
<ul>
<li>封装性的体现，需要权限修饰符来配合。</li>
<li>1.Java 规定的 4 种权限：(从小到大排序)private、缺省、protected、public</li>
<li>2.4 种权限用来修饰类及类的内部结构：属性、方法、构造器、内部类</li>
<li>3.具体的，4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li>
<li><pre><code>     修饰类的话，只能使用：缺省、public
</code></pre>
</li>
<li>总结封装性：Java 提供了 4 中权限修饰符来修饰类积累的内部结构，体现类及类的内部结构的可见性的方法。</li>
</ul>
<h3 id="2-2四种访问权限修饰符"><a href="#2-2四种访问权限修饰符" class="headerlink" title="2.2四种访问权限修饰符"></a>2.2四种访问权限修饰符</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/c10d9f7a2cfc118c122baa567ba968ca.png" alt="img"></p>
<h2 id="3-构造器（类的成员之三）"><a href="#3-构造器（类的成员之三）" class="headerlink" title="3.构造器（类的成员之三）"></a>3.构造器（类的成员之三）</h2><h3 id="3-1构造器理解"><a href="#3-1构造器理解" class="headerlink" title="3.1构造器理解"></a>3.1构造器理解</h3><pre><code class="java">/*
 * 类的结构之三:构造器(构造方法、constructor)的使用
 * constructor:
 * 
 * 一、构造器的作用:
 * 1.创建对象
 * 2.初始化对象的属性
 * 
 * 二、说明
 * 1.如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器。
 * 2.定义构造器的格式:
 * 			权限修饰符  类名(形参列表) &#123; &#125;
 * 3.一个类中定义的多个构造器，彼此构成重载。
 * 4.一旦显示的定义了类的构造器之后，系统不再提供默认的空参构造器。
 * 5.一个类中，至少会有一个构造器		
 */
public class PersonTest &#123;

    public static void main(String[] args) &#123;
        //创建类的对象:new + 构造器
        Person p = new Person();	//Person()这就是构造器
        
        p.eat();
        
        Person p1 = new Person(&quot;Tom&quot;);
        System.out.println(p1.name);
    &#125;
&#125;
class Person&#123;
    //属性
    String name;
    int age;
    
    //构造器
    public Person()&#123;
        System.out.println(&quot;Person()......&quot;);
    &#125;
    
    public Person(String n)&#123;
        name = n;
    &#125;
    
    public Person(String n,int a)&#123;
        name = n;
        age = a;
    &#125;
    
    //方法
    public void eat()&#123;
        System.out.println(&quot;人吃饭&quot;);
    &#125;
    
    public void study()&#123;
        System.out.println(&quot;人学习&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3-2属性赋值的过程"><a href="#3-2属性赋值的过程" class="headerlink" title="3.2属性赋值的过程"></a>3.2属性赋值的过程</h3><pre><code class="java">/*
 * 总结:属性赋值的先后顺序
 * 
 * ① 默认初始化值
 * ② 显式初始化
 * ③ 构造器中赋值
 * ④ 通过&quot;对象.方法&quot; 或 “对象.属性”的方式，赋值
 * 
 * 以上操作的先后顺序:① - ② - ③ - ④
 * 
 */
public class UserTest &#123;

    public static void main(String[] args) &#123;
        User u = new User();
        
        System.out.println(u.age);
        
        User u1 = new User(2);
        
        u1.setAge(3);
        
        System.out.println(u1.age);
    &#125;
&#125;
class User&#123;
    String name;
    int age = 1;
    
    public User()&#123;
        
    &#125;
    
    public User(int a)&#123;
        age = a;
    &#125;
    
    public void setAge(int a)&#123;
        age = a;
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/35c39171e6d8d7a2a25bd0c9edd48ee9.png" alt="img"></p>
<pre><code class="Java">/*
 * 对属性可以赋值的位置:
 *  ①默认初始化
 *  ②显式初始化 / ⑤在代码块中赋值
 *  ③构造器中初始化
 *  ④有了对象以后，可以通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方式，进行赋值。
 *  
 *  执行的先后顺序:① - ② / ⑤ - ③ - ④
 */
public class OrderTest &#123;
    public static void main(String[] args) &#123;
        Order order = new Order();
        System.out.println(order.orderId);
    &#125;
&#125;
class Order&#123;
    
    int orderId = 3;
    &#123;
        orderId = 4;
    &#125;
    
&#125;
</code></pre>
<h3 id="3-3Javabean"><a href="#3-3Javabean" class="headerlink" title="3.3Javabean"></a>3.3Javabean</h3><pre><code class="java">/*
 * JavaBean 是一种 Java 语言写成的可重用组件。
 * 所谓 javaBean，是指符合如下标准的 Java 类：
 * 		&gt; 类是公共的
 * 		&gt; 有一个无参的公共的构造器
 * 		&gt; 有属性，且有对应的 get、set 方法
 * 
 */
public class Customer &#123;
    
    private int id;
    private String name;

    public Customer()&#123;
        
    &#125;
    
    public void setId(int i)&#123;
        id = i;
    &#125;
    
    public int getId()&#123;
        return id;
    &#125;
    
    public void setName(String n)&#123;
        name = n;
    &#125;
    
    public String getName()&#123;
        return name;
    &#125;
&#125;
</code></pre>
<h3 id="3-4-UML类图"><a href="#3-4-UML类图" class="headerlink" title="3.4 UML类图"></a>3.4 UML类图</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/4245a65d9610ec85f6b80c6f520d989e.png" alt="img"></p>
<ul>
<li>表示 public 类型，-表示 private 类型，#表示 protected 类型</li>
<li>方法的写法: 方法的类型(+、-) 方法名(参数名：参数类型)：返回值类型</li>
</ul>
<h3 id="3-5关于构造器的一些补充理解"><a href="#3-5关于构造器的一些补充理解" class="headerlink" title="3.5关于构造器的一些补充理解"></a>3.5关于构造器的一些补充理解</h3><p>Person类</p>
<pre><code class="Java">public class Person &#123;

    String name;
    int age;
    int id = 1003;	//身份证号
    
    public Person()&#123;
        System.out.println(&quot;我无处不在&quot;);
    &#125;
    
    public Person(String name)&#123;
        this.name = name;
    &#125;
    
    public Person(String name,int age)&#123;
        this(name);
        this.age = age;
    &#125;
    
    public void eat()&#123;
        System.out.println(&quot;人，吃饭&quot;);
    &#125;
    
    public void walk()&#123;
        System.out.println(&quot;人，走路&quot;);
    &#125;
&#125;
</code></pre>
<p>Student类</p>
<pre><code class="Java">public class Student extends Person&#123;
    
    String major;
    int id = 1002;	//学号
    
    public Student()&#123;

    &#125;
    
    public Student(String name,int age,String major)&#123;
//		this.age = age;
//		this.name = name;
        super(name,age);
        this.major = major;
    &#125;
    
    public Student(String major)&#123;
        this.major = major;
    &#125;
    
    public void eat()&#123;
        System.out.println(&quot;学生多吃有营养的食物&quot;);
    &#125;
    
    public void Study()&#123;
        System.out.println(&quot;学生，学习知识。&quot;);
        this.eat();
        //如果，想调用父类中被重写的，不想调用子类中的方法，可以：
        super.eat();
        super.walk();//子父类中未重写的方法，用&quot;this.&quot;或&quot;super.&quot;调用都可以
    &#125;
    public void show()&#123;
        System.out.println(&quot;name = &quot; + this.name + &quot;,age = &quot; + super.age);
        System.out.println(&quot;id = &quot; + this.id);	
        System.out.println(&quot;id = &quot; + super.id);
    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="Java">public class SuperTest &#123;
    public static void main(String[] args) &#123;
        
        Student s = new Student();
        s.show();
        
        s.Study();
        
        Student s1 = new Student(&quot;Ton&quot;,21,&quot;IT&quot; );
        s1.show();
        
        System.out.println(&quot;***********************&quot;);
        Student s2 = new Student();
        
    &#125;
&#125;
</code></pre>
<p>运行结果</p>
<p>![](C:\Users\立夏\Desktop\屏幕截图 2023-01-03 222021.jpg)</p>
<h2 id="4-this的使用"><a href="#4-this的使用" class="headerlink" title="4.this的使用"></a>4.this的使用</h2><h3 id="4-1-this调用属性，方法，构造器"><a href="#4-1-this调用属性，方法，构造器" class="headerlink" title="4.1.this调用属性，方法，构造器"></a>4.1.this调用属性，方法，构造器</h3><pre><code class="java">/*
 * this 关键字的使用
 * 1.this 用来修饰、调用：属性、方法、构造器
 * 
 * 2.this 修饰属性和方法:
 * 		this 理解为：当前对象,或当前正在创建的对象。
 * 	 
 *  2.1 在类的方法中，我们可以使用&quot;this.属性&quot;或&quot;this.方法&quot;的方式，调用当前对象属性和方法。
 *  	通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名，我们必须显式
 *  	的使用&quot;this.变量&quot;的方式，表明此变量是属性，而非形参。
 * 
 *  2.2 在类的构造器中，我们可以使用&quot;this.属性&quot;或&quot;this.方法&quot;的方式，调用正在创建的对象属性和方法。
 *  	但是，通常情况下，我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名，我们必须显式
 *  	的使用&quot;this.变量&quot;的方式，表明此变量是属性，而非形参。
 *  
 *  3.this 调用构造器
 *  	① 我们可以在类的构造器中，显式的使用&quot;this(形参列表)&quot;的方式，调用本类中重载的其他的构造器！
 *  	② 构造器中不能通过&quot;this(形参列表)&quot;的方式调用自己。
 *  	③ 如果一个类中声明了n个构造器，则最多有n -1个构造器中使用了&quot;this(形参列表)&quot;。
 *  	④ &quot;this(形参列表)&quot;必须声明在类的构造器的首行！
 *  	⑤ 在类的一个构造器中，最多只能声明一个&quot;this(形参列表)&quot;。
 */
public class PersonTest &#123;

    public static void main(String[] args) &#123;
        Person p1 = new Person();
        
        p1.setAge(1);
        System.out.println(p1.getAge());
        
        p1.eat();
        System.out.println();
        
        Person p2 = new Person(&quot;jerry&quot; ,20);
        System.out.println(p2.getAge());
    &#125;
&#125;
class Person&#123;
    
    private String name;
    private int age;
    
    public Person()&#123;
        this.eat();
        String info = &quot;Person 初始化时，需要考虑如下的 1,2,3,4...(共 40 行代码)&quot;;
        System.out.println(info);
    &#125;
    
    public Person(String name)&#123;
        this();
        this.name = name;
    &#125;
    
    public Person(int age)&#123;
        this();
        this.age = age;
    &#125;
    
    public Person(String name,int age)&#123;
        this(age);	//调用构造器的一种方式
        this.name = name;
//		this.age = age;
    &#125;
    
    public void setNmea(String name)&#123;
        this.name = name;
    &#125;
    
    public String getName()&#123;
        return this.name;
    &#125;
    
    public void setAge(int age)&#123;
        this.age = age;
    &#125;
    
    public int getAge()&#123;
        return this.age;
    &#125;
    
    public void eat()&#123;
        System.out.println(&quot;人吃饭&quot;);
        this.study();
    &#125;
    
    public void study()&#123;
        System.out.println(&quot;学习&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="5-package、import-的使用"><a href="#5-package、import-的使用" class="headerlink" title="5.package、import 的使用"></a>5.package、import 的使用</h2><h3 id="5-1package"><a href="#5-1package" class="headerlink" title="5.1package"></a>5.1package</h3><pre><code class="java">/*
 * 一、package 关键字的使用
 * 1.为了更好的实现项目中类的管理，提供包的概念
 * 2.使用 package 声明类或接口所属的包，声明在源文件的首行
 * 3.包，属于标识符，遵循标识符的命名规则、规范&quot;见名知意&quot;
 * 4.每“.”一次,就代表一层文件目录。
 * 
 * 补充:同一个包下，不能命名同名接口或同名类
 *     不同包下，可以命名同名的接口、类。
 *
 */
public class PackageImportTest &#123;

&#125;
</code></pre>
<h3 id="5-2import"><a href="#5-2import" class="headerlink" title="5.2import"></a>5.2import</h3><pre><code class="java">import java.util.*;

import account2.Bank;

/*
 * 二、import关键字的使用
 * import:导入
 * 1.在源文件中显式的使用import结构导入指定包下的类、接口
 * 2.声明在包的声明和类的声明之间
 * 3.如果需要导入多个结构，则并列写出即可
 * 4.可以使用&quot;xxx.*&quot;的方式,表示可以导入xxx包下的所有结构。
 * 5.如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。
 * 6.如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。
 * 7.如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。
 * 8.import static组合的使用：调用指定类或接口下的静态的属性或方法.
 * 
 */
public class PackageImportTest &#123;

    public static void main(String[] args) &#123;
        String info = Arrays.toString(new int[]&#123;1,2,3&#125;);
        
        Bank bank = new Bank();
        
        ArrayList list = new ArrayList();
        HashMap map = new HashMap();
        
        Scanner s = null;	
        
        System.out.println(&quot;hello&quot;);
        
        UserTest us = new UserTest();
        
    &#125;
&#125;
</code></pre>
<h1 id="面向对象2"><a href="#面向对象2" class="headerlink" title="面向对象2"></a>面向对象2</h1><h2 id="6-面向对象特征之二：继承性"><a href="#6-面向对象特征之二：继承性" class="headerlink" title="6.面向对象特征之二：继承性"></a>6.面向对象特征之二：继承性</h2><h3 id="6-1继承性的理解"><a href="#6-1继承性的理解" class="headerlink" title="6.1继承性的理解"></a>6.1继承性的理解</h3><pre><code class="Java">/*
 * 面向对象的特征二:继承性
 * 
 * 为什么要有继承？
 * 		多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，
 * 		那么多个类无需再定义这些属性和行为，只要继承那个类即可。
 *  * 一、继承性的好处
 * ① 减少了代码的冗余，提高了代码的复用性；
 * ② 便于功能的扩展；
 * ③ 为之后多态性的使用，提供了前提。
 * 
 * 二、继承性的格式
 * 	class A extends B&#123;&#125;
 *  A:子类、派生类、subclass
 *  B:父类、超类、基类、superclass
 *  
 *  2.1 体现：一旦子类 A 继承父类以后，子类 A 中就获取了父类 B 中声明的结构：属性、方法
 * 		特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。
 * 		只有因为封装性的影响，使得子类不能直接调用父类的结构而已。
 *  2.2 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展。
 *  	子类和父类的关系：不同于子集与集合的关系。
 *  	extends:延展、扩展
 * 
 */
public class ExtendsTest &#123;

    public static void main(String[] args) &#123;
        Person p1 = new Person();
//		p1.age = 1;
        p1.eat();
        System.out.println(&quot;********************&quot;);
        
        Student s1 = new Student();
        s1.eat();
//		s1.sleep();
        s1.name = &quot;Tom&quot;;
        
        s1.setAge(10);
        System.out.println(s1.getAge());
        
    &#125;
&#125;
/*  三、Java 中关于继承性的规定：
 *  	1.一个类可以被多个类继承
 *  	2.Java 中类的单继承性：一个类只能有一个父类
 *  	3.子父类是相对的概念。
 *  	4.子类直接继承的父类，称为：直接父类。间接继承的父类，称为，间接父类。
 *  	5.子类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法。
 * 	
 * 四、1.如果我们没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类
 * 	  2.所有的 java 类(除 java.long.Object 类之外)都直接或间接地继承于 java.lang.Object 类;
 * 	  3.意味着，所有的 java 类具有 java.lang.Object 类声明的功能。
 */
public class ExtendsTest &#123;

    public static void main(String[] args) &#123;	
        s1.brease();
        
        Creature c = new Creature();
        System.out.println(c.toString());
        
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cc9569b92c2b8879b873cd05741fe753.png" alt="img"><img src="https://img-blog.csdnimg.cn/img_convert/cb041fed5ec912d35815aa8e72d8ecdf.png" alt="img"></p>
<h3 id="6-2继承性的练习"><a href="#6-2继承性的练习" class="headerlink" title="6.2继承性的练习"></a>6.2继承性的练习</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/c0be1eac6215b7a27e0b209d2fb4dd97.png" alt="img"></p>
<p>circle类</p>
<pre><code class="java">public class Circle &#123;

    public double radius;	//半径
    
    public Circle()&#123;
        radius = 1.0;
    &#125;

    public double getRadius() &#123;
        return radius;
    &#125;

    public void setRadius(double radius) &#123;
        this.radius = radius;
    &#125;
    
    public double findArea()&#123;	//计算圆的面积
        return Math.PI * radius * radius;
    &#125;
&#125;
</code></pre>
<p>Cylinder类</p>
<pre><code class="java">public class Cylinder extends Circle&#123;

    private double length;
    
    public Cylinder()&#123;
        length = 1.0;
    &#125;

    public double getLength() &#123;
        return length;
    &#125;

    public void setLength(double length) &#123;
        this.length = length;
    &#125;
    
    public double findVolume()&#123;	//计算圆柱体积
        return findArea() * length;
    &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code class="Java">public class CylinderTest &#123;
    public static void main(String[] args) &#123;
        
        Cylinder cy = new Cylinder();
        
        cy.setRadius(2.1);
        cy.setLength(3.4);
        double volues = cy.findVolume();
        System.out.println(&quot;圆柱的体积:&quot; + volues);
        
        double area = cy.findArea();
        System.out.println(&quot;圆的面积: &quot; + area);
    &#125;
&#125;
</code></pre>
<h2 id="7-方法的重写"><a href="#7-方法的重写" class="headerlink" title="7.方法的重写"></a>7.方法的重写</h2><h3 id="7-1重写的理解"><a href="#7-1重写的理解" class="headerlink" title="7.1重写的理解"></a>7.1重写的理解</h3><pre><code class="Java">/*
 * 方法的重写(override/overwrite)
 * 
 * 1.重写：子类继承父类以后，可以对父类中的方法进行覆盖操作。
 * 2.应用：重写以后，当创建子类对象以后，通过子类对象去调用子父类中同名同参数方法时，执行的是子类重写父类的方法。
 *   即在程序执行时，子类的方法将覆盖父类的方法。
 * 
 * 面试题：区分方法的重载与重写(有的书也叫做“覆盖”)
 * 		答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。
 * 		重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。
 * 		如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
 * 		子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&quot;屏蔽&quot;了。
 * 		如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。
 * 
 */

public class PersonTest &#123;


    public static void main(String[] args) &#123;
        Student s = new Student(&quot;计算机科学与技术&quot;);
        s.eat();
        s.walk(10);
        
        s.study();
    &#125;
&#125;
/*
 * 3.重写的规定：
 * 		方法的声明：权限修饰符 返回值类型 方法名(形参列表)&#123;
 * 						//方法体
 * 				 &#125;
 * 		约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法。
 * 		① 子类重写的方法的方法名和形参列表必须和父类被重写的方法的方法名、形参列表相同; 
 * 		② 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限,
 *   		特殊情况: 子类不能重写父类中声明为private权限的方法;
 *   	③ 返回值类型:
 *   		&gt; 父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void;
 *   		&gt; 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类;
 *   		&gt; 父类被重写的方法的返回值类型如果是基本数据类型(比如:double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须是:double)。
 *   		
 *   	④ 子类方法抛出的异常不能大于父类被重写的方法抛出的异常;
 * 
 * 注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。
 * 		因为static方法是属于类的，子类无法覆盖父类的方法。
 */
public class PersonTest &#123;


    public static void main(String[] args) &#123;
        Student s = new Student(&quot;计算机科学与技术&quot;);
        s.eat();
        s.walk(10);
        System.out.println(&quot;*******************&quot;);
        
        s.study();
        
        Person p1 = new Person();
        p1.eat();
    &#125;
&#125;
</code></pre>
<h2 id="8-super"><a href="#8-super" class="headerlink" title="8.super"></a>8.super</h2><h3 id="8-1super"><a href="#8-1super" class="headerlink" title="8.1super"></a>8.1super</h3><pre><code class="Java">/*
 * super关键字的使用
 * 1.super理解为:父类的
 * 2.super可以用来调用:属性、方法、构造器 
 * 
 * 3.super的使用
 * 		3.1 我们可以在子类的方法或构造器中，通过&quot;super.属性&quot;或&quot;super.方法&quot;的方式，显式的调用
 * 	父类中声明的属性或方法。但是，通常情况下，我们习惯去省略这个&quot;super.&quot;
 * 		3.2 特殊情况:当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的 
 *  使用&quot;super.属性&quot;的方式，表明调用的是父类中声明的属性。
 *  	3.3 特殊情况:当子类重写了父类中的方法后，我们想在子类的方法中调用父类中被重写的方法时，必须显式的
 *  使用&quot;super.方法&quot;的方式，表明调用的是父类中被重写的方法。
 * 
 * 4.super调用构造器
 * 	  4.1  我们可以在子类的构造器中显式的使用&quot;super(形参列表)&quot;的方式,调用父类中声明的指定的构造器
 * 	  4.2 &quot;super(形参列表)&quot;的使用，必须声明在子类构造器的首行！
 *    4.3 我们在类的构造器中，针对于&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;只能二选一，不能同时出现。
 *    4.4 在构造器的首行，既没有显式的声明&quot;this(形参列表)&quot;或&quot;super(形参列表)&quot;,则默认的调用的是父类中的空参构造器。super()
 *    4.5 在类的多个构造器中，至少有一个类的构造器使用了&quot;super(形参列表)&quot;,调用父类中的构造器。
 *  
 */
public class SuperTest &#123;
    public static void main(String[] args) &#123;
        
        Student s = new Student();
        s.show();
        
        s.Study();
        
        Student s1 = new Student(&quot;Ton&quot;,21,&quot;IT&quot; );
        s1.show();
        
        System.out.println(&quot;***********************&quot;);
        Student s2 = new Student();
        
    &#125;
&#125;
</code></pre>
<h2 id="9-子类对象实例化"><a href="#9-子类对象实例化" class="headerlink" title="9.子类对象实例化"></a>9.子类对象实例化</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/2add7cbc6ccf4e7b02966a050c178675.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/408eeec5cf31085be7d7e0321aa39b3d.png" alt="img"></p>
<pre><code class="java">/*
 * 子类对象实例化的全过程
 * 
 * 1.从结果上看:
 * 		子类继承父类以后，就获取了父类中声明的属性或方法。
 * 		创建子类的对象中，在堆空间中，就会加载所有父类中声明的属性。
 * 
 * 2.从过程上看:
 * 		当我们通过子类的构造器创建子类对象时,我们一定会直接或间接的调用其父类构造器， 
 * 		直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中有
 * 		父类中的结构，子类对象可以考虑进行调用。
 * 
 * 明确:虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象。
 */
public class InstanceTest &#123;

&#125;
</code></pre>
<h2 id="10-面向对象特征之三：多态性"><a href="#10-面向对象特征之三：多态性" class="headerlink" title="10.面向对象特征之三：多态性"></a>10.面向对象特征之三：多态性</h2><h3 id="10-1多态性的理解"><a href="#10-1多态性的理解" class="headerlink" title="10.1多态性的理解"></a>10.1多态性的理解</h3><pre><code class="Java">/*
 * 面向对象之三:多态性
 * 
 * 1.理解多态性:可以理解为一个事物的多种态性。
 * 2.何为多态性:
 * 	 对象的多态性:父类的引用指向子类的对象(或子类的对象赋值给父类的引用)
 * 
 * 3.多态的使用：虚拟方法调用
 * 	有了对象多态性以后，我们在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法
 * 			简称：编译时，看左边；运行时，看右边。
 *  
 *  若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
 *  多态情况下，
 *  	“看左边”：看的是父类的引用（父类中不具备子类特有的方法）
 *  	“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）
 *  
 *  4.多态性的使用前提：
 *  	① 类的继承关系
 *  	② 方法的重写
 *  5.对象的多态性:只适用于方法，不适用于属性(编译和运行都看左边)
 */
public class PersonTest &#123;
    public static void main(String[] args) &#123;
        
    Person p1 = new Person();
    p1.eat();
    
    Man man = new Man();
    man.eat();
    man.age = 25;
    man.earnMoney();
    
    //************************************
    //对象的多态性，父类的引用指向子类的对象
    Person p2 = new Man();
//	Person p3 = new Woman();
    
    //多态的使用:当调用子父类同名同参数方法时，实际调用的是子类重写父类的方法---虚拟方法调用
    p2.eat();
    p2.walk();
    
//	p2.earnMoney();
    
    &#125;
&#125;
import java.util.Random;
/*
 * 2.从编译和运行的角度看：
 * 重载，是指允许存在多个同名方法，而这些方法的参数不同。
 * 编译器根据方法不同的参数表，对同名方法的名称做修饰。
 * 对于编译器而言，这些同名方法就成了不同的方法。
 * 它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，
 * 即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，
 * 编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
 * 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，
 * 这称为“晚绑定”或“动态绑定”。
 * 
 * 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”
 */
//面试题：多态是编译时行为还是运行时行为？
//证明如下：
class Animal  &#123;
 
    protected void eat() &#123;
        System.out.println(&quot;animal eat food&quot;);
    &#125;
&#125;

class Cat  extends Animal  &#123;
 
    protected void eat() &#123;
        System.out.println(&quot;cat eat fish&quot;);
    &#125;
&#125;

class Dog  extends Animal  &#123;
 
    public void eat() &#123;
        System.out.println(&quot;Dog eat bone&quot;);

    &#125;

&#125;

class Sheep  extends Animal  &#123;
 
    public void eat() &#123;
        System.out.println(&quot;Sheep eat grass&quot;);

    &#125;
 
&#125;

public class InterviewTest &#123;

    public static Animal  getInstance(int key) &#123;
        switch (key) &#123;
        case 0:
            return new Cat ();
        case 1:
            return new Dog ();
        default:
            return new Sheep ();
        &#125;

    &#125;

    public static void main(String[] args) &#123;
        int key = new Random().nextInt(3);

        System.out.println(key);

        Animal  animal = getInstance(key);
        
        animal.eat();
         
    &#125;

&#125;
</code></pre>
<h3 id="10-2向下转型与向上转型"><a href="#10-2向下转型与向上转型" class="headerlink" title="10.2向下转型与向上转型"></a>10.2向下转型与向上转型</h3><pre><code class="java">向下转型主要实现可以调用子类的特有的属性与方法
public class PersonTest &#123;
    public static void main(String[] args) &#123;

        Person p1 = new Person();
        p1.eat();

        Man man = new Man();
        man.eat();
        man.age = 25;
        man.earnMoney();

        // ************************************
        System.out.println(&quot;************************&quot;);
        // 对象的多态性，父类的引用指向子类的对象
        Person p2 = new Man();
        // Person p3 = new Woman();

        // 多态的使用:当调用子父类同名同参数方法时，实际调用的是子类重写父类的方法---虚拟方法调用
        p2.eat();
        p2.walk();

        // p2.earnMoney();

        System.out.println(&quot;**************************&quot;);
        // 不能调用子类所特有的方法、属性，编译时，p2是Person类型，

        // p2.earnMoney();

        p2.name = &quot;Tom&quot;;
        // p2.isSmoking = true;
        // 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致
        // 编译时，只能调用父类中声明的属性和方法。子类的属性和方法不能调用。

        // 如何才能调用子类所特有的属性和方法？
        // 使用强制类型转换符，也可称为:向下转型
        Man m1 = (Man) p2;
        m1.earnMoney();
        m1.isSmoking = true;

        // 使用强转时，可能出现ClassCastException异常
        // Woman w1 = (Woman)p2;
        // w1.goShopping();

        /*
         * instanceof关键字的使用
         * 
         * a instanceof A:判断对象a是否是类A的实例。如果，返回true，如果不是，返回false;
         * 
         * 使用情境:为了避免在向下转型时出现ClassCastException异常，我们在进行向下转型之前，先进行
         * instanceof的判断,一旦返回true,就进行向下转型。如果返回false，不进行向下转型。
         * 
         * 如果a instanceof A返回true,则a instanceof B也返回true。 其中类B是类A的父类。
         * 
         */

        if (p2 instanceof Woman) &#123;
            Woman w1 = (Woman) p2;
            w1.goShopping();
            System.out.println(&quot;**********Woman*********&quot;);
        &#125;

        if (p2 instanceof Man) &#123;
            Man m2 = (Man) p2;
            m2.earnMoney();
            System.out.println(&quot;*********Man************&quot;);
        &#125;

        if (p2 instanceof Person) &#123;
            System.out.println(&quot;***********Person************&quot;);
        &#125;

        if (p2 instanceof Object) &#123;
            System.out.println(&quot;***********object************&quot;);
        &#125;
        
        //向下转型的常见问题
        //练习
        //问题1:编译时通过，运行时不通过
        //举例一
//		Person p3 = new Woman();
//		Man m3 = (Man)p3;
        
        //举例二
        Person p4 = new Person();
        Man m4 = (Man)p4;
        
        //问题二:编译通过，运行时也通过
        Object obj = new Woman();
        Person p = (Person)obj;
        
        //问题三:编译不通过
//		Man m5 = new woman();
        
//		String str = new Date();
        
//		Object o = new Date();
//		String str1 = (String)o;
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c6dcce377d1fae98ba497cc11d3b4163.png" alt="img"></p>
<h3 id="10-3多态性的补充"><a href="#10-3多态性的补充" class="headerlink" title="10.3多态性的补充"></a>10.3多态性的补充</h3><pre><code class="Java">/*
 * 练习:子类继承父类
 * 
 * 1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，
 * 系统将不可能把父类里的方法转移到子类中。
 * 
 * 2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，
 * 这个实例变量依然不可能覆盖父类中定义的实例变量
 * 
 */
public class FieldMethodTest &#123;
    public static void main(String[] args)&#123;
        Sub s= new Sub();
        System.out.println(s.count);	//20
        s.display();//20
        
        Base b = s;
        //==:对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否一样。
        System.out.println(b == s);	//true
        System.out.println(b.count);	//10
        b.display();
    &#125;
&#125;

class Base &#123;
    int count= 10;
    public void display() &#123;
        System.out.println(this.count);
    &#125;
&#125;

class Sub extends Base &#123;
    int count= 20;
    public void display() &#123;
        System.out.println(this.count);
    &#125;
&#125;
</code></pre>
<h2 id="11object类"><a href="#11object类" class="headerlink" title="11object类"></a>11object类</h2><pre><code class="Java">/*
 * java.lang.Object类
 * 1.Object类是所有Java类的根父类;
 * 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
 * 3.Object类中的功能(属性、方法)就具有通用性。
 * 属性:无
 * 方法:equals() / toString() / getClass() / hashCode() / clone() /finalize()
 * 	 wait() 、notify()、notifyAll()
 * 
 * 4.Object类只声明了一个空参的构造器。
 * 
 * 面试题:
 * final、finally、finalize的区别？
 * 
 */
public class ObjectTest &#123;

    public static void main(String[] args) &#123;
        
    &#125;
&#125;

class Order&#123;
    
&#125;
</code></pre>
<h3 id="11-1Object类中的主要结构"><a href="#11-1Object类中的主要结构" class="headerlink" title="11.1Object类中的主要结构"></a>11.1Object类中的主要结构</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/d9de1281feb25f434a69f809adeb4a24.png" alt="img"></p>
<h3 id="11-2-x3D-x3D-操作符与equals方法"><a href="#11-2-x3D-x3D-操作符与equals方法" class="headerlink" title="11.2&#x3D;&#x3D;操作符与equals方法"></a>11.2&#x3D;&#x3D;操作符与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>方法</h3><pre><code class="Java">import java.sql.Date;

/*
 * 面试题: ==和equals的区别
 * 
 * 一、回顾==的使用
 * == : 运算符
 * 1.可以使用在基本数据类型变量和引用数据类型变量中
 * 2.如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。(不一定类型要相同)
 * 	   如果比较的是引用数据类型变量：比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体
 *  补充: == 符号使用时，必须保证符号左右两边的变量类型一致。
 *
 * 二、equals()方法的使用
 * 1.是一个方法，而非运算符
 * 2.只能适用于引用数据类型。
 * 3.Object类中equals()的定义：
 * 		public boolean equals(Object obj)&#123;
 * 			return (this == obj);
 * 		&#125;
 * 说明：Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。
 * 
 * 4.像String、Date、File、包装类等都重写了Object类中的equals()方法.
 * 	 两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。
 * 
 * 5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的&quot;实体内容&quot;是否相同。那么，我们
 * 	   就需要对Object类中的equals()进行重写。
 * 
 * 重写的原则:比较两个对象的实体内容是否相同。
 * 
 */
public class EqualsTest &#123;
    public static void main(String[] args) &#123;
        
        //基本数据类型
        int i = 10;
        int j = 10;
        double d = 10.0;
        System.out.println(i == j);	//true
        System.out.println(i == d); //true
        
//		boolean b =true;
//		System.out.println(i == b);
        
        char c = 10;
        System.out.println(i == c); //true
        
        char c1 = &#39;A&#39;;
        char c2 = 65;
        System.out.println(c1 == c2); //true
        
        //引用数据类型
        Customer cust1 = new Customer(&quot;Tom&quot; ,21);
        Customer cust2 = new Customer(&quot;Tom&quot; ,21);
        System.out.println(cust1 == cust2); //false
        
        String str1 = new String(&quot;BAT&quot;);
        String str2 = new String(&quot;BAT&quot;);
        System.out.println(str1 == str2); //false
        System.out.println(&quot;*************************&quot;);
        System.out.println(cust1.equals(cust2));	//false
        System.out.println(str1.equals(str2));	//true
        
        Date date1 = new Date(23432525324L);
        Date date2 = new Date(23432525324L);
        System.out.println(date1.equals(date2));	//true
    &#125;
&#125;
</code></pre>
<ul>
<li>对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</li>
<li>自反性：x.equals(x)必须返回是“true”。</li>
<li>传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</li>
<li>一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。</li>
<li>任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。</li>
</ul>
<h3 id="11-3toString的使用"><a href="#11-3toString的使用" class="headerlink" title="11.3toString的使用"></a>11.3toString的使用</h3><pre><code class="Java">import java.util.Date;
/*
 * Object类中toString()的使用
 * 
 * 1.当我们输出一个引用对象时，实际上就是调用当前对象的toString()
 * 2.Object类中toString的定义方法
 * 	public String toString() &#123;
 *      return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
 *  &#125;
 * 
 * 3.像String、Date、File、包装类等都重写了Object类中的toString()方法。
 * 	 使得在调用toString()时，返回&quot;实体内容&quot;信息.
 * 
 * 4.自定义类如果重写toString()方法，当调用此方法时，返回对象的&quot;实体内容&quot;.
 */
public class ToStringTest &#123;
    public static void main(String[] args) &#123;
        
        Customer cust1 = new Customer(&quot;Tom&quot; ,21);
        System.out.println(cust1.toString());	//github4.Customer@15db9742
        System.out.println(cust1); 	//github4.Customer@15db9742 ---&gt; Customer[name = Tom,age = 21]
        
        String str = new String(&quot;MM&quot;);
        System.out.println(str);
        
        Date date = new Date(45362348664663L);
        System.out.println(date.toString());	//Wed Jun 24 12:24:24 CST 3407
        
    &#125;
&#125;
</code></pre>
<h2 id="12-包装类-Wrapper-的使用"><a href="#12-包装类-Wrapper-的使用" class="headerlink" title="12.包装类(Wrapper)的使用"></a>12.包装类(Wrapper)的使用</h2><h3 id="12-1单元测试方法的使用"><a href="#12-1单元测试方法的使用" class="headerlink" title="12.1单元测试方法的使用"></a>12.1单元测试方法的使用</h3><pre><code class="Java">import java.util.Date;
import org.junit.Test;
/*
 * java中的JUnit单元测试
 * 
 * 步骤:
 * 1.选中当前项目工程 --》 右键:build path --》 add libraries --》 JUnit 4 --》 下一步
 * 2.创建一个Java类进行单元测试。
 * 	 此时的Java类要求:①此类是公共的 ②此类提供一个公共的无参构造器 
 * 3.此类中声明单元测试方法。
 *   此时的单元测试方法:方法的权限是public,没有返回值，没有形参。
 * 
 * 4.此单元测试方法上需要声明注解:@Test并在单元测试类中调用:import org.junit.Test;
 * 5.声明好单元测试方法以后，就可以在方法体内测试代码。
 * 6.写好代码后，左键双击单元测试方法名：右键 --》 run as --》 JUnit Test
 * 
 * 说明:如果执行结果无错误，则显示是一个绿色进度条，反之，错误即为红色进度条。
 */
public class JUnit &#123;
    
    int num = 10;
    
    //第一个单元测试方法
    @Test
    public void testEquals()&#123;
        String s1 = &quot;MM&quot;;
        String s2 = &quot;MM&quot;;
        System.out.println(s1.equals(s2));
        
        //ClassCastException的异常
//		Object obj = new String(&quot;GG&quot;);
//		Date date = (Date)obj;
        
        System.out.println(num);
        show();
    &#125;
    
    public void show()&#123;
        num = 20;
        System.out.println(&quot;show()...&quot;);
    &#125;
    
    //第二个单元测试方法
    @Test
    public void testToString()&#123;
        String s2 = &quot;MM&quot;;
        System.out.println(s2.toString());
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9cacb9d5a49fbe6e8ca4f7831975db7d.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2ed96054861a4fa797a564eee2d09cbb.png" alt="img"></p>
<h3 id="12-2包装类的使用"><a href="#12-2包装类的使用" class="headerlink" title="12.2包装类的使用"></a>12.2包装类的使用</h3><pre><code class="java">/*
 * 包装类的使用
 * 1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征
 * 		基本数据类型		包装类
 * 		byte			Byte
 * 		short			Short
 * 		int 			Integer
 * 		long			Long
 * 		float			Float
 * 		double			Double
 * 		boolean			Boolean
 * 		char			Character
 * 注意:其中Byte、Short、Integer、Long、Float、Double的父类是:Number
 * /
</code></pre>
<h3 id="12-3包装类与基本数据类型相互转换"><a href="#12-3包装类与基本数据类型相互转换" class="headerlink" title="12.3包装类与基本数据类型相互转换"></a>12.3包装类与基本数据类型相互转换</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/fa0116bbaf03d264cc9650a3319da2a8.png" alt="img"></p>
<pre><code class="java">import org.junit.Test;
/*
 * 2.基本数据类型、包装类、String三者之间的相互转换。
 * 
 */
public class WrapperTest &#123;
    
    //String类型---&gt; 基本数据类型、包装类,调用包装类的parseXxx()
    @Test
    public void test5()&#123;
        String str1 = &quot;123&quot;;
//		String str1 = &quot;123a&quot;;
        
        //错误的情况，可能会报错
//		int num1 = (int)str1;
//		Integer in1 = (Integer)str1;
        
        int num2 = Integer.parseInt(str1); 
        System.out.println(num2 + 1);	//124
        
        String str2 = &quot;true&quot;;
        Boolean b1 = Boolean.parseBoolean(str2);
        System.out.println(b1);	//true
        
    &#125;
    
    //基本数据类型、包装类---》String类型，调用String重载的valueOf(Xxx xxx)
    @Test
    public void test4()&#123;
        int num1 = 10;
        //方式1:连接运算
        String str1 = num1 + &quot;&quot;;
        //方式2:调用String的valueOf(Xxx xxx)
        float f1 = 12.3f;
        String str2 = String.valueOf(f1); //&quot;12.3&quot;
        
        Double d1 = new Double(12.4);
        String str3 = String.valueOf(d1);
        System.out.println(str2);
        System.out.println(str3);	//&quot;12.4&quot;
        
    &#125;
    
    /*
     * JDK 5.0 新特性:自动装箱与自动拆箱
     */
    @Test
    public void test3()&#123;
//		int num1 = 10;
//		//基本数据类型 --》 包装类的对象
//		method(num1);	//Object obj = num1
        
        //自动装箱:基本数据类型 --》 包装类
        int num2 = 10;
        Integer in1 = num2;//自动装箱
        
        boolean b1 = true;
        Boolean b2 = b1;//自动装箱
        
        //自动拆箱：包装类 --》 基本数据类型
        System.out.println(in1.toString());
        
        int num3 = in1;
        
    &#125;
    
    public void method(Object obj)&#123;
        System.out.println(obj);
    &#125;
    
    //包装类 --》 基本数据类型:调用包装类的xxxValue()
    @Test
    public void test2() &#123;
        Integer in1 = new Integer(12);
        int i1 = in1.intValue();
        System.out.println(i1 + 1); 
        
        Float f1 = new Float(12.3f);
        float f2 = f1.floatValue();
        System.out.println(f2 + 1); 
    &#125;
    
    //基本数据类型--》包装类,调用包装类的构造器
    @Test
    public void test1() &#123;
        int num1 = 10;
//		System.out.println(num1.toString());
        
        Integer in1 = new Integer(num1);
        System.out.println(in1.toString());
        
        Integer in2 = new Integer(&quot;123&quot;);
        System.out.println(in2.toString());
        
        //报异常
//		Integer in3 = new Integer(&quot;123abc&quot;);
//		System.out.println(in3.toString());
        
        Float f1 = new Float(12.3f);
        Float f2 = new Float(&quot;12.3&quot;);
        System.out.println(f1);
        System.out.println(f2);
        
        Boolean b1 = new Boolean(true);
        Boolean b2 = new Boolean(&quot;true&quot;);
        
        Boolean b3 = new Boolean(&quot;true123&quot;);
        System.out.println(b3); //false
        
        Order order = new Order();
        System.out.println(order.isMale); //false
        System.out.println(order.isFemale); //null
        
    &#125;
&#125;

class Order&#123;
    
    boolean isMale;
    Boolean isFemale;
&#125;
</code></pre>
<p>编程练习：向量类的运用<img src="https://img-blog.csdnimg.cn/img_convert/c80ea8669572b20379dbbd018fadb155.png" alt="img"></p>
<pre><code class="java">import java.util.Scanner;
import java.util.Vector;

/*
 * 利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），
 * 找出最高分，并输出学生成绩等级。
 * 
 * 提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。
 * 而向量类java.util.Vector可以根据需要动态伸缩。
 * 
 * 创建Vector对象：Vector v=new Vector();
 * 给向量添加元素：v.addElement(Object obj);   //obj必须是对象
 * 取出向量中的元素：Object  obj=v.elementAt(0);
 * 注意第一个元素的下标是0，返回值是Object类型的。
 * 计算向量的长度：v.size();
 * 若与最高分相差
 * 		10分内：A等；
 * 		20分内：B等；
 * 		30分内：C等；
 * 		其它：D等
 * 
 */
public class VectorTest &#123;
    public static void main(String[] args) &#123;
        // 1.实例化Scanner，用于从键盘获取学生成绩
        Scanner scan = new Scanner(System.in);

        // 2.创建Vector对象：Vector v=new Vector();相当于原来的数组
        Vector v = new Vector();

        // 3.通过for(;;)或while(true)方式，给Vector中添加数组
        int maxScore = 0;
        for (;;) &#123;
            System.out.println(&quot;请输入学生成绩（以负数代表输入结束）&quot;);
            int score = scan.nextInt();
            // 3.2 当输入是负数时，跳出循环
            if (score &lt; 0) &#123;
                break;
            &#125;
            if (score &gt; 100) &#123;
                System.out.println(&quot;输入的数据非法，请重新输入&quot;);
                continue;
            &#125;
            // 3.1 添加操作：：v.addElement(Object obj)
            // jdk5.0之前：
            // Integer inScore = new Integer(score);
            // v.addElement(inScore);//多态
            // jdk5.0之后：
            v.addElement(score);// 自动装箱
            // 4.获取学生成绩的最大值
            if (maxScore &lt; score) &#123;
                maxScore = score;
            &#125;
        &#125;

        // 5.遍历Vector，得到每个学生的成绩，并与最大成绩比较，得到每个学生的等级。
        char level;
        for (int i = 0; i &lt; v.size(); i++) &#123;
            Object obj = v.elementAt(i);
            // jdk 5.0之前：
            // Integer inScore = (Integer)obj;
            // int score = inScore.intValue();
            // jdk 5.0之后：
            int score = (int) obj;

            if (maxScore - score &lt;= 10) &#123;
                level = &#39;A&#39;;
            &#125; else if (maxScore - score &lt;= 20) &#123;
                level = &#39;B&#39;;
            &#125; else if (maxScore - score &lt;= 30) &#123;
                level = &#39;C&#39;;
            &#125; else &#123;
                level = &#39;D&#39;;
            &#125;

            System.out.println(&quot;student-&quot; + i + &quot; score is &quot; + score + &quot;,level is &quot; + level);

        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="13static"><a href="#13static" class="headerlink" title="13static"></a>13static</h2><h3 id="13-1static的理解"><a href="#13-1static的理解" class="headerlink" title="13.1static的理解"></a>13.1static的理解</h3><p>我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，<strong>某些特定的数据在内存空间里只有一份。</strong></p>
<p>例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<pre><code class="Java">/*
 * static 关键字的使用
 * 
 * 1.static:静态的。
 * 2.static 可以用来修饰:属性、方法、代码块、内部类。
 * 
 * 3.使用 static 修饰属性:静态变量(或类变量)。
 * 		3.1  属性:是否使用 static 修饰，又分为:静态属性 VS 非静态属性(实例变量)
 * 		   实例变量:我们创建了类的多个对象，每个对象都独立的拥有了一套类中的非静态属性。
 * 				当修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修饰。
 * 		   静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过静态变量去修改某一个变量时，
 * 				会导致其他对象调用此静态变量时，是修改过的。
 * 		3.2 static 修饰属性的其他说明:
 * 			① 静态变量随着类的加载而加载。可以通过&quot;类.静态变量&quot;的方式进行调用。
 * 			② 静态变量的加载要早于对象的创建。
 * 			③ 由于类只会加载一次，则静态变量在内存中也只会存在一次。存在方法区的静态域中。
 * 
 * 			④ 		类变量		实例变量
 * 			类		yes			no
 * 			对象		yes			yes
 * 
 * 		3.3 静态属性举例:System.out.Math.PI;
 *  
 */
public class StaticTest &#123;
    public static void main(String[] args) &#123;
        
        Chinese.nation = &quot;中国&quot;;
        
        Chinese c1 = new Chinese();
        c1.name = &quot;姚明&quot;;
        c1.age = 40;
        c1.nation = &quot;CHN&quot;;
        
        Chinese c2 = new Chinese();
        c2.name = &quot;马龙&quot;;
        c2.age = 30;
        c2.nation = &quot;CHINA&quot;;
        
        System.out.println(c1.nation); 
        
        //编译不通过
//		Chinese.name = &quot;张继科&quot;;
        
    &#125;
&#125;
//中国人
class Chinese&#123;
    
    String name;
    int age;
    static String nation;
&#125;
/* 
 * 4.使用 static 修饰方法:静态方法
 * 		① 随着类的加载而加载，可以通过&quot;类.静态方法&quot;的方式调用
 * 		② 			静态方法		非静态方法
 * 			类		yes			no
 * 			对象		yes			yes
 * 		③ 静态方法中，只能调用静态的方法或属性
 * 		  非静态的方法中，可以调用所有的方法或属性
 * 
 * 5.static 注意点:
 * 	 5.1  在静态的方法内，不能使用 this 关键字、super 关键字
 *   5.2 关于静态属性和静态方法的使用，大家从生命周期的角度去理解。
 *   
 * 6.开发中，如何确定一个属性是否需要声明 static 的？
 * 	 》 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
 * 	 》 类中的常量也常常声明为 static
 *   
 *   开发中，如何确定一个方法是否要声明为 static 的？
 *   》 操作静态属性的方法，通常设置为 static 的
 *   》 工具类中的方法，习惯上声明为 static 的。比如：Math、Arrays、Collections
 * 	 
 */
public class StaticTest &#123;
    public static void main(String[] args) &#123;
        
        Chinese.nation = &quot;中国&quot;;
        
        Chinese c1 = new Chinese();
        
        //编译不通过
//		Chinese.name = &quot;张继科&quot;;
        
        c1.eat();
        
        Chinese.show();
        //编译不通过
//		chinese.eat();
//		Chinese.info();
    &#125;
&#125;
//中国人
class Chinese&#123;
    
    String name;
    int age;
    static String nation;
    
    public void eat()&#123;
        System.out.println(&quot;中国人吃中餐&quot;);
        //调用非静态结构
        this.info();
        System.out.println(&quot;name : &quot; + name);
        //调用静态结构
        walk();
        System.out.println(&quot;nation : &quot; + Chinese.nation);
    &#125;
    
    public static void show()&#123;
        System.out.println(&quot;我是一个中国人！&quot;);
//		eat();
//		name = &quot;Tom&quot;;
        //可以调用静态的结构
        System.out.println(Chinese.nation);
        walk();
    &#125;
    
    public void info()&#123;
        System.out.println(&quot;name : &quot; + name + &quot;,age : &quot; + age);
    &#125;
    
    public static void walk()&#123;
        
    &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/img_convert/97cc52e6668ddb59b0a2fc1d63b99607.png" alt="img"></p>
<p>static的练习</p>
<pre><code class="Java">/*
 * 编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、
 * “利率”、“最小余额”，定义封装这些属性的方法。
 * 账号要自动生成。编写主类，使用银行账户类，输入、输出 3 个储户的上述信息。
 * 考虑：哪些属性可以设计成 static 属性。
 * 
 */
public class Account &#123;
    
    private int id;	//账号
    private String pwd = &quot;000000&quot;;	//密码
    private double balance; //存款余额
    
    private static double interestRate; //利率
    private static double minMoney = 1.0;  //最小余额
    private static int init = 1001;	//用于自动生成 id
    
    public Account()&#123;	//账号自动生成
        id = init++;
    &#125;
    
    public Account(String pwd,double balance)&#123;
        id = init++;
        this.pwd = pwd;
        this.balance = balance;
    &#125;
    
    public String getPwd() &#123;
        return pwd;
    &#125;
    
    public void setPwd(String pwd) &#123;
        this.pwd = pwd;
    &#125;
    
    public static double getInterestRate() &#123;
        return interestRate;
    &#125;
    
    public static void setInterestRate(double interestRate) &#123;
        Account.interestRate = interestRate;
    &#125;
    
    public static double getMinMoney() &#123;
        return minMoney;
    &#125;
    
    public static void setMinMoney(double minMoney) &#123;
        Account.minMoney = minMoney;
    &#125;
    
    public int getId() &#123;
        return id;
    &#125;
    
    public double getBalance() &#123;
        return balance;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Account [id=&quot; + id + &quot;, pwd=&quot; + pwd + &quot;, balance=&quot; + balance + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="Java">public class AccountTest &#123;
    public static void main(String[] args) &#123;
        
        Account acct1 = new Account();
        Account acct2 = new Account(&quot;qwerty&quot;,2000);
        
        Account.setInterestRate(0.012); 
        Account.setMinMoney(100);
        
        System.out.println(acct1);
        System.out.println(acct2);
        
        System.out.println(acct1.getInterestRate()); 
        System.out.println(acct1.getMinMoney());
    &#125;
&#125;
</code></pre>
<h3 id="13-2单例-Singleton-设计模式"><a href="#13-2单例-Singleton-设计模式" class="headerlink" title="13.2单例(Singleton)设计模式"></a>13.2单例(<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Singleton&spm=1001.2101.3001.7020">Singleton</a>)设计模式</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为 private，这样，就不能用 new 操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p>
<p>1饿汉式</p>
<pre><code class="Java">/*
 * 单例设计模式:
 * 1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例
 *  
 * 2.如何实现？
 *   饿汉式	VS	懒汉式
 * 
 * 3.区分饿汉式和懒汉式。
 * 	   饿汉式：坏处:对象加载时间过长。
 * 	 	       好处:饿汉式是线程安全的。
 * 
 *   懒汉式：好处:延迟对象的创建。
 * 		       坏处:目前的写法，会线程不安全。---》到多线程内容时，再修改
 */
public class SingletonTest &#123;
    public static void main(String[] args) &#123;
//		Bank bank1 = new Bank(); 
//		Bank bank2 = new Bank(); 
        
        Bank bank1 = Bank.getInstance();
        Bank bank2 = Bank.getInstance();
        
        System.out.println(bank1 == bank2);
        
    &#125;
&#125;

//单例的饿汉式
class Bank&#123;
    
    //1.私有化类的构造器
    private Bank()&#123;
        
    &#125;
    
    //2.内部创见类的对象
    //4.要求此对象也必须声明为静态的
    private static Bank instance = new Bank();
    
    //3.提供公共的静态的方法，返回类的对象。
    public static Bank getInstance()&#123;
        return instance;
    &#125;
&#125;
</code></pre>
<p>2.<strong>单例模式的懒汉式</strong></p>
<pre><code class="Java">/*
 * 单例的懒汉式实现
 * 
 */
public class SingletonTest2 &#123;
    public static void main(String[] args) &#123;
        
        Order order1 = Order.getInstance();
        Order order2 = Order.getInstance();
        
        System.out.println(order1 == order2);
    &#125;
&#125;
class Order&#123;
    //1.私有化类的构造器
    private Order()&#123;
        
    &#125;
    
    //2.声明当前类对象，没有初始化。
    //此对象也必须声明为 static 的
    private static Order instance = null;
    
    //3.声明 public、static 的返回当前类对象的方法
    public static Order getInstance()&#123;
        if(instance == null)&#123;
            instance = new Order();			
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h2 id="14-类的成员之四：代码块"><a href="#14-类的成员之四：代码块" class="headerlink" title="14.类的成员之四：代码块"></a>14.类的成员之四：代码块</h2><pre><code class="Java">/*
 * 类的成员之四:代码块（或初始化块）
 * 
 * 1.代码块的作用：用来初始化类、对象的
 * 2.代码块如果有修饰的话，只能使用 static
 * 3.分类:静态代码块 vs 非静态代码块
 * 
 * 4.静态代码块
 * 	》内部可以有输出语句
 *  》随着类的加载而执行,而且只执行一次
 *  》作用:初始化类的信息
 *  》如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行
 *  》静态代码块的执行，优先于非静态代码块的执行
 *  》静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
 * 
 * 5.非静态代码块
 *  &gt;内部可以有输出语句
 *  &gt;随着对象的创建而执行
 *  &gt;每创建一个对象，就执行一次非静态代码块。
 *  &gt;作用:可以在创建对象时，对对象的属性等进行初始化。
 *  &gt;如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行
 *  &gt;非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法。
 *  
 * 对属性可以赋值的位置:
 *  ①默认初始化
 *  ②显式初始化
 *  ③构造器中初始化
 *  ④有了对象以后，可以通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方式，进行赋值。
 *  ⑤在代码块中赋值
 */
public class BlockTest &#123;
    public static void main(String[] args) &#123;
        
        String desc = Person.desc;
        System.out.println(desc);
        
        Person p1 = new Person();
        Person p2 = new Person();
        System.out.println(p1.age);
        
        Person.info();
    &#125;
&#125;

class Person&#123;
    //属性
    String name;
    int age;
    static String desc = &quot;我是一个青年&quot;;
    
    //构造器
    public Person()&#123;
        
    &#125;
    
    //static 的代码块
    static&#123;
        System.out.println(&quot;hello,static block-1&quot;);
        //调用静态结构
        desc = &quot;我是一个爱小说的人&quot;;
        info();
        //不能调用非静态结构
//		eat();
//		name = &quot;Tom&quot;;
    &#125;
    
    static&#123;
        System.out.println(&quot;hello,static block-2&quot;);
    &#125;
    
    //非 static 的代码块
    &#123;
        System.out.println(&quot;hello,block-2&quot;);
    &#125;
    &#123;
        System.out.println(&quot;hello,block-1&quot;);
        //调用非静态结构
        age = 1;
        eat();
        //调用静态结构
        desc = &quot;我是一个爱小说的人 1&quot;;
        info();
    &#125;	
    
    //方法
    public Person(String name,int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
    
    public void eat()&#123;
        System.out.println(&quot;吃饭&quot;);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
    &#125;
    public static void info()&#123;
        System.out.println(&quot;我是一个快乐的人。&quot;);
    &#125;
    
&#125;
</code></pre>
<p><strong>静态初始化块举例 1</strong></p>
<pre><code class="Java">//总结:由父类到子类，静态先行
class Root&#123;
    static&#123;
        System.out.println(&quot;Root 的静态初始化块&quot;);
    &#125;
    &#123;
        System.out.println(&quot;Root 的普通初始化块&quot;);
    &#125;
    public Root()&#123;
        System.out.println(&quot;Root 的无参数的构造器&quot;);
    &#125;
&#125;
class Mid extends Root&#123;
    static&#123;
        System.out.println(&quot;Mid 的静态初始化块&quot;);
    &#125;
    &#123;
        System.out.println(&quot;Mid 的普通初始化块&quot;);
    &#125;
    public Mid()&#123;
        System.out.println(&quot;Mid 的无参数的构造器&quot;);
    &#125;
    public Mid(String msg)&#123;
        //通过 this 调用同一类中重载的构造器
        this();
        System.out.println(&quot;Mid 的带参数构造器，其参数值：&quot;
            + msg);
    &#125;
&#125;
class Leaf extends Mid&#123;
    static&#123;
        System.out.println(&quot;Leaf 的静态初始化块&quot;);
    &#125;
    &#123;
        System.out.println(&quot;Leaf 的普通初始化块&quot;);
    &#125;	
    public Leaf()&#123;
        //通过 super 调用父类中有一个字符串参数的构造器
        super(&quot;尚硅谷&quot;);
        System.out.println(&quot;Leaf 的构造器&quot;);
    &#125;
&#125;
public class LeafTest&#123;
    public static void main(String[] args)&#123;
        new Leaf(); 
        //new Leaf();
    &#125;
&#125;
</code></pre>
<h2 id="15-final"><a href="#15-final" class="headerlink" title="15.final"></a>15.final</h2><pre><code class="java1">/*
 * final:最终的
 * 
 * 1.final可以用来修饰的结构:类、方法、变量
 * 
 * 2.final用来修饰一个类:此类不能被其他类所继承。
 * 		  比如:String类、System类、StringBuffer类
 * 3.final修饰一个方法:final标记的方法不能被子类重写。
 * 		  比如：Object类中的getClass()。 
 * 4.final用来修饰变量:此时的&quot;变量&quot;(成员变量或局部变量)就是一个常量。名称大写，且只能被赋值一次。
 * 	 4.1 final修饰属性，可以考虑赋值的位置有:显式初始化、代码块中初始化、构造器中初始化
 *   4.2 final修饰局部变量:
 *   	 尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。
 *      一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
 *      
 * static final 用来修饰:全局常量
 */
public class FinalTest &#123;
    
    final int WIDTH = 0;
    final int LEFT;
    final int RIGHT;
//	final int DOWN;
    
    &#123;
        LEFT = 1;
    &#125;
    
    public FinalTest()&#123;
        RIGHT = 2;
    &#125;
    
    public FinalTest(int n)&#123;
        RIGHT = n;
    &#125;
    
//	public void setDown(int down)&#123;
//		this.DOWN = down;
//	&#125;
    
    public void dowidth()&#123;
//		width = 20;	//width cannot be resolved to a variable
    &#125;
    
    public void show()&#123;
        final int NUM = 10;	//常量
//		num += 20;
    &#125;
    
    public void show(final int num)&#123;
        System.out.println(num);
    &#125;
    
    public static void main(String[] args) &#123;
        
        int num = 10;
        
        num = num + 5;
        
        FinalTest test = new FinalTest();
//		test.setDown(5);
        
        test.show(10);
    &#125;
&#125;

final class FianlA&#123;
    
&#125;

//class B extends FinalA&#123;     //错误，不能被继承。
//	
//&#125;

//class C extends String&#123;
//	
//&#125;

class AA&#123;
    public final void show()&#123;
        
    &#125;
&#125;

//class BB extends AA&#123;	// 错误，不能被重写。
//	public void show()&#123;
//		
//	&#125;
//&#125;
</code></pre>
<h2 id="16-抽象类与抽象方法"><a href="#16-抽象类与抽象方法" class="headerlink" title="16.抽象类与抽象方法"></a>16.抽象类与抽象方法</h2><h3 id="16-1抽象类理解"><a href="#16-1抽象类理解" class="headerlink" title="16.1抽象类理解"></a>16.1抽象类理解</h3><pre><code class="Java">/*
 * abstract 关键字的使用
 * 
 * 1.abstract:抽象的
 * 2.abstract 可以用来修饰的结构:类、方法
 * 3.abstract 修饰类:抽象类
 * 	》 此类不能实例化
 *  》 抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化全过程)
 *  》 开发中，都会提供抽象类的子类，让子类对象实例化，实现相关的操作
 * 
 * 4.abstract 修饰方法:抽象方法
 *  &gt; 抽象方法，只有方法的声明，没有方法体。
 *  &gt; 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法
 *  &gt; 若子类重写了父类中所有的抽象方法，此子类，
 *
 * abstract 使用上的注意点:
 * 1.abstract 不能用来修饰变量、代码块、构造器；
 * 
 * 2.abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类。
 * 
 */
public class AbstractTest &#123;
    public static void main(String[] args) &#123;
        //一旦 Person 类抽象了，就不可实例化
//		Person p1 = new Person();
//		p1.eat();
        
    &#125;
&#125;

abstract class Creature&#123;
    public abstract void breath();
&#125;

abstract class Person extends Creature&#123;
    String name;
    int age;
    
    public Person()&#123;
        
    &#125;
    
    public Person(String name,int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
    
    //不是抽象方法
//	public void eat()&#123;
//		System.out.println(&quot;人吃饭&quot;);
//	&#125;
    
    //抽象方法
    public abstract void eat();
    
    public void walk()&#123;
        System.out.println(&quot;人走路&quot;);
    &#125;
&#125;

class Student extends Person&#123;
    public Student(String name,int age)&#123;
        super(name,age);
    &#125;
    public void eat()&#123;
        System.out.println(&quot;学生应该多吃有营养的。&quot;);
    &#125;
    @Override
    public void breath() &#123;
        System.out.println(&quot;学生应该呼吸新鲜的无雾霾空气&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="16-2抽象类应用"><a href="#16-2抽象类应用" class="headerlink" title="16.2抽象类应用"></a>16.2抽象类应用</h3><p>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fae4ad700aef40c0402a7e092da91106.png" alt="img"></p>
<p>问题：卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle 类不能提供计算方法，但子类可以。</p>
<pre><code class="Java">/* Java 允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提  供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。
 * Vehicle 是一个抽象类，有两个抽象方法。
 * 注意：抽象类不能实例化 new Vihicle()是非法的
 */
public abstract class Vehicle&#123;
    public abstract double calcFuelEfficiency();//计算燃料效率的抽象方法
    public abstract double calcTripDistance();//计算行驶距离的抽象方法
&#125;
public class Truck extends Vehicle&#123;
    public double calcFuelEfficiency()&#123; 
        //写出计算卡车的燃料效率的具体方法
    &#125;
    public double calcTripDistance()&#123; 
        //写出计算卡车行驶距离的具体方法
    &#125;
&#125;
public class RiverBarge extends Vehicle&#123;
    public double calcFuelEfficiency() &#123; 
        //写出计算驳船的燃料效率的具体方法
    &#125;
    public double calcTripDistance( )  &#123;  
        //写出计算驳船行驶距离的具体方法
    &#125;
&#125;
</code></pre>
<h3 id="16-3创建抽象类的匿名子类对象"><a href="#16-3创建抽象类的匿名子类对象" class="headerlink" title="16.3创建抽象类的匿名子类对象"></a>16.3创建抽象类的匿名子类对象</h3><pre><code class="Java">public class Num &#123;

&#125;

abstract class Creature&#123;
    public abstract void breath();
&#125;

abstract class Person extends Creature&#123;
    String name;
    int age;
    
    public Person()&#123;
        
    &#125;
    
    public Person(String name,int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
    
    //不是抽象方法
//	public void eat()&#123;
//		System.out.println(&quot;人吃饭&quot;);
//	&#125;
    
    //抽象方法
    public abstract void eat();
    
    public void walk()&#123;
        System.out.println(&quot;人走路&quot;);
    &#125;
&#125;

class Student extends Person&#123;
    public Student(String name,int age)&#123;
        super(name,age);
    &#125;
    public Student()&#123;

    &#125;
    public void eat()&#123;
        System.out.println(&quot;学生应该多吃有营养的。&quot;);
    &#125;
    @Override
    public void breath() &#123;
        System.out.println(&quot;学生应该呼吸新鲜的无雾霾空气&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="16-4抽象类的练习"><a href="#16-4抽象类的练习" class="headerlink" title="16.4抽象类的练习"></a>16.4抽象类的练习</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/a36e51e665b20673f270cb9b2b921e20.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/56ace48e046b22da15db7100a2edfccb.png" alt="img"></p>
<p>1、Employee 类</p>
<pre><code class="Java">/*
 * 定义一个 Employee 类，
 * 该类包含：private 成员变量 name,number,birthday，
 * 其中 birthday 为 MyDate 类的对象；
 * abstract 方法 earnings()；
 * toString()方法输出对象的 name,number 和 birthday。
 * 
 */
public abstract class Employee &#123;
    private String name;
    private int number;
    private MyDate birthday;
    
    public Employee(String name, int number, MyDate birthday) &#123;
        super();
        this.name = name;
        this.number = number;
        this.birthday = birthday;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getNumber() &#123;
        return number;
    &#125;

    public void setNumber(int number) &#123;
        this.number = number;
    &#125;

    public MyDate getBirthday() &#123;
        return birthday;
    &#125;

    public void setBirthday(MyDate birthday) &#123;
        this.birthday = birthday;
    &#125;

    public abstract double earnings();

    @Override
    public String toString() &#123;
        return &quot;name=&quot; + name + &quot;, number=&quot; + number + &quot;, birthday=&quot; + birthday.toDateString() + &quot;]&quot;;
    &#125;
    
&#125;
</code></pre>
<p>2、MyDate 类</p>
<pre><code class="Java">/*
 * MyDate 类包含:private 成员变量 year,month,day；
 * toDateString()方法返回日期对应的字符串：xxxx 年 xx 月 xx 日
 */
public class MyDate &#123;
    private int year;
    private int month;
    private int day;
    
    public MyDate(int year, int month, int day) &#123;
        super();
        this.year = year;
        this.month = month;
        this.day = day;
    &#125;

    public int getYear() &#123;
        return year;
    &#125;

    public void setYear(int year) &#123;
        this.year = year;
    &#125;

    public int getMonth() &#123;
        return month;
    &#125;

    public void setMonth(int month) &#123;
        this.month = month;
    &#125;

    public int getDay() &#123;
        return day;
    &#125;

    public void setDay(int day) &#123;
        this.day = day;
    &#125;

    public String toDateString()&#123;
        return year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;;
    &#125;
&#125;
</code></pre>
<p>3、SalariedEmployee 类</p>
<pre><code class="java">/*
 * 定义 SalariedEmployee 类继承 Employee 类，实现按月计算工资的员工处理。
 * 该类包括：private 成员变量 monthlySalary；实现父类的抽象方法 earnings(),
 * 该方法返回 monthlySalary 值；
 * toString()方法输出员工类型信息及员工的 name，number,birthday。
 * 
 */
public class SalariedEmployee extends Employee&#123;
    private double monthlySalary;	//月工资

    public SalariedEmployee(String name,int number,MyDate birthday) &#123;
        super(name,number,birthday);
    &#125;
    
    public SalariedEmployee(String name, int number, MyDate birthday, double monthlySalary) &#123;
        super(name, number, birthday);
        this.monthlySalary = monthlySalary;
    &#125;

    @Override
    public double earnings() &#123;
        return monthlySalary;		
    &#125;

    @Override
    public String toString() &#123;
        return &quot;SalariedEmployee [&quot; + super.toString() + &quot;]&quot;;
    &#125;	
&#125;
</code></pre>
<p>4、HourlyEmployee 类</p>
<pre><code class="Java">/*
 * 参照 SalariedEmployee 类定义 HourlyEmployee 类，
 * 实现按小时计算工资的员工处理。该类包括：private 成员变量 wage 和 hour；
 * 实现父类的抽象方法 earnings(),该方法返回 wage*hour 值；
 * toString()方法输出员工类型信息及员工的 name，number,birthday。
 * 
 */
public class HourlyEmployee extends Employee&#123;
    private int wage;	//每小时的工资
    private int hour;	//月工作的小时数
    
    public HourlyEmployee(String name, int number, MyDate birthday) &#123;
        super(name, number, birthday);
    &#125;

    public HourlyEmployee(String name, int number, MyDate birthday, int wage, int hour) &#123;
        super(name, number, birthday);
        this.wage = wage;
        this.hour = hour;
    &#125;

    @Override
    public double earnings() &#123;
        return wage*hour;
    &#125;

    public int getWage() &#123;
        return wage;
    &#125;

    public void setWage(int wage) &#123;
        this.wage = wage;
    &#125;

    public int getHour() &#123;
        return hour;
    &#125;

    public void setHour(int hour) &#123;
        this.hour = hour;
    &#125;
    
    public String toString()&#123;
        return &quot;HourlyEmployee[&quot; + super.toString() + &quot;]&quot;; 
    &#125;
&#125;
</code></pre>
<p>5.PayrollSystem 类</p>
<pre><code class="java">import java.util.Calendar;
import java.util.Scanner;
/*
 * 定义 PayrollSystem 类，创建 Employee 变量数组并初始化，
 * 该数组存放各类雇员对象的引用。利用循环结构遍历数组元素，
 * 输出各个对象的类型,name,number,birthday,以及该对象生日。
 * 当键盘输入本月月份值时，
 * 如果本月是某个 Employee 对象的生日，还要输出增加工资信息。
 * 
 */
public class PayrollSystem &#123;
    public static void main(String[] args) &#123;
        //方式一：
//		Scanner scanner = new Scanner(System.in);
//		System.out.println(&quot;请输入当月的月份：&quot;);
//		int month = scanner.nextInt();
        
        //方式二：
        Calendar calendar = Calendar.getInstance();
        int month = calendar.get(Calendar.MONTH);//获取当前的月份
//		System.out.println(month);//一月份：0
        
        Employee[] emps = new Employee[2];
        
        emps[0] = new SalariedEmployee(&quot;马良&quot;, 1002,new MyDate(1992, 2, 28),10000);
        emps[1] = new HourlyEmployee(&quot;博西&quot;, 2001, new MyDate(1991, 1, 6),60,240);
        
        for(int i = 0;i &lt; emps.length;i++)&#123;
            System.out.println(emps[i]);
            double salary = emps[i].earnings();
            System.out.println(&quot;月工资为：&quot; + salary);
            
            if((month+1) == emps[i].getBirthday().getMonth())&#123;
                System.out.println(&quot;生日快乐！奖励 100 元&quot;);
            &#125;
            
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="17-接口"><a href="#17-接口" class="headerlink" title="17.接口"></a>17.接口</h2><h3 id="17-1接口的理解"><a href="#17-1接口的理解" class="headerlink" title="17.1接口的理解"></a>17.1接口的理解</h3><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。</p>
<p>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is-a 的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3 机、手机、数码相机、移动硬盘等都支持 USB 连接。</p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是”能不能”的关系。</p>
<p><strong>接口的本质是契约，标准，规范</strong>，就像我们的法律一样。制定好后大家都要遵守。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/aec8823d72652f568ac820b927069e4e.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/729b5a0b77e2881568a2c029920e0f2e.png" alt="img"></p>
<pre><code class="Java">/* 接口(interface)是抽象方法和常量值定义的集合。
 * 接口的特点：
 * 用 interface 来定义。
 * 接口中的所有成员变量都默认是由 public static final 修饰的。
 * 接口中的所有抽象方法都默认是由 public abstract 修饰的。
 * 接口中没有构造器。
 * 接口采用多继承机制。
 */
/*
 * 接口的使用
 * 1.接口使用 interface 来定义。
 * 2.在 Java 中:接口和类是并列的两个结构
 * 3.如何去定义两个接口:定义接口中的成员
 * 	》3.1 JDK7 及以前:只能定义全局常量和抽象方法
 * 		》全局常量:public static final 的,但是书写中，可以省略不写。
 * 		》抽象方法:public abstract 的
 * 
 *  》3.2 JDK8:除了全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)。
 * 
 * 4.接口中不能定义构造器！意味着接口不可以实例化。
 * 
 * 5.Java 开发中，接口通过让类去实现(implements)的方式来使用。
 *   如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化
 *   如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
 * 
 * 6.Java 类可以实现多个接口 ---》弥补了 Java 单继承性的局限性
 *  格式:class AA extends BB implementd CC,DD,EE
 *  
 *  7.接口与接口之间是继承,而且可以多继承
 *  
 **********************************
 * 8.接口的具体使用，体现多态性
 * 	   接口的主要用途就是被实现类实现。（面向接口编程）
 * 9.接口，实际可以看作是一种规范
 * 
 * 面试题:抽象类与接口有哪些异同？
 *  
 */
public class InterfaceTest &#123;
    public static void main(String[] args) &#123;
        System.out.println(Flayable.MAX_SPEED);
        System.out.println(Flayable.MIN_SPEED);
    &#125;
&#125;
interface Flayable&#123;
    
    //全局变量
    public static final int MAX_SPEED = 7900;	
    int MIN_SPEED = 1;//省略了 public static final 
    
    //抽象方法
    public abstract void fly();
    
    void stop();//省略了 public abstract 
    //Interfaces cannot have constructors
//	public Flayable()&#123;
//		
//	&#125;	
&#125;
interface Attackable&#123;
    void attack();
&#125;

class Plane implements Flayable&#123;

    @Override
    public void fly() &#123;
        System.out.println(&quot;飞机通过引擎起飞&quot;);
        
    &#125;

    @Override
    public void stop() &#123;
        System.out.println(&quot;驾驶员减速停止&quot;);
    &#125;
    
&#125;
abstract class Kite implements Flayable&#123;

    @Override
    public void fly() &#123;
        
    &#125;
&#125;

class Bullet extends Object implements Flayable,Attackable,CC&#123;

    @Override
    public void attack() &#123;
        // TODO Auto-generated method stub
        
    &#125;

    @Override
    public void fly() &#123;
        // TODO Auto-generated method stub
        
    &#125;

    @Override
    public void stop() &#123;
        // TODO Auto-generated method stub
        
    &#125;

    @Override
    public void method1() &#123;
        // TODO Auto-generated method stub
        
    &#125;

    @Override
    public void method2() &#123;
        // TODO Auto-generated method stub
        
    &#125;
&#125;

//*********************************
interface AA&#123;
    void method1();
&#125;
interface BB&#123;
    void method2();
&#125;
interface CC extends AA,BB&#123;
    
&#125;
/*
 * 接口的使用
 * 1.接口使用上也满足多态性
 * 2.接口，实际上就是定义了一种规范
 * 3.开发中，体会面向接口编程！
 * 
 */
public class USBTest &#123;
    public static void main(String[] args) &#123;
        
        Computer com = new Computer();
        //1.创建了接口的非匿名实现类的非匿名对象
        Flash flash = new Flash();
        com.transferData(flash); 
        //2. 创建了接口的非匿名实现类的匿名对象
        com.transferData(new Printer());
        //3. 创建了接口的匿名实现类的非匿名对象
        USB phone = new USB()&#123;

            @Override
            public void start() &#123;
                System.out.println(&quot;手机开始工作&quot;);
            &#125;

            @Override
            public void stop() &#123;
                System.out.println(&quot;手机结束工作&quot;);
            &#125;
            
        &#125;;
        com.transferData(phone);
        //4. 创建了接口的匿名实现类的匿名对象
        com.transferData(new USB()&#123;
            @Override
            public void start() &#123;
                System.out.println(&quot;mp3 开始工作&quot;);
            &#125;

            @Override
            public void stop() &#123;
                System.out.println(&quot;mp3 结束工作&quot;);
            &#125;
        &#125;);
    &#125;
&#125;

class Computer&#123;
    
    public void transferData(USB usb)&#123;//USB usb = new Flash();
        usb.start();
        
        System.out.println(&quot;具体传输数据的细节&quot;);
        
        usb.stop();
    &#125;
    
&#125;

interface USB&#123;
    //常量:定义了长、宽
    void start();
    
    void stop();
&#125;
class Flash implements USB&#123;

    @Override
    public void start() &#123;
        System.out.println(&quot;U 盘开始工作&quot;);
    &#125;

    @Override
    public void stop() &#123;
        System.out.println(&quot;U 盘结束工作&quot;);
    &#125;
&#125;
class Printer implements USB&#123;
    @Override
    public void start() &#123;
        System.out.println(&quot;打印机开启工作&quot;);
    &#125;

    @Override
    public void stop() &#123;
        System.out.println(&quot;打印机结束工作&quot;);
    &#125;
    
&#125;
</code></pre>
<h3 id="17-2接口的练习"><a href="#17-2接口的练习" class="headerlink" title="17.2接口的练习"></a>17.2接口的练习</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/6593e549625053470aca56f338387d98.png" alt="img"></p>
<p>CompareObject 类</p>
<pre><code class="Java">/*
 * 定义一个接口用来实现两个对象的比较。
 * 
 */
public interface CompareObject &#123;
    public int compareTo(Object o);
    //若返回值是 0,代表相等;若为正数，代表当前对象大；负数代表当前对象小
    
&#125;
</code></pre>
<p>circle 类</p>
<pre><code class="Java">/*
 * 定义一个 Circle 类，声明 redius 属性，提供 getter 和 setter 方法
 */
public class Circle &#123;
    
    private Double radius;

    public Double getRadius() &#123;
        return radius;
    &#125;

    public void setRadius(Double radius) &#123;
        this.radius = radius;
    &#125;

    public Circle() &#123;
        super();
    &#125;

    public Circle(Double radius) &#123;
        super();
        this.radius = radius;
    &#125;
        
&#125;
</code></pre>
<p>ComparableCircle 类</p>
<pre><code class="java">/*
 * 定义一个 ComparableCircle 类，继承 Circle 类并且实现 CompareObject 接口。在 ComparableCircle 类中给出接口中方法 compareTo 的实现体，
 * 用来比较两个圆的半径大小。
 */
public class ComparableCircle extends Circle implements CompareObject&#123;

    public ComparableCircle(double radius) &#123;
        super(radius);
    &#125;
    @Override
    public int compareTo(Object o) &#123;
        if(this == o)&#123;
            return 0;
        &#125;
        if(o instanceof ComparableCircle)&#123;
            ComparableCircle c = (ComparableCircle)o;
            //错误的写法
//			return (int)(this.getRedius() - c.getRedius());
            //正确的方式一：
//			if(this.getRadius() &gt; c.getRadius())&#123;
//				return 1;
//			&#125;else if(this.getRadius() &lt; c.getRadius())&#123;
//				return -1;
//			&#125;else&#123;
//				return 0;
//			&#125;
            //当属性 radius 声明为 Double 类型时，可以调用包装类的方法
            //正确的方式二：
            return this.getRadius().compareTo(c.getRadius());
        &#125;else&#123;
            return 0;
//			throw new RuntimeException(&quot;传入数据类型不匹配&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>InterfaceTest 类</p>
<pre><code>/*
 * 定义一个测试类 InterfaceTest，创建两个 ComparableCircle 对象，
 * 调用 compareTo 方法比较两个类的半径大小。
 * 
 */
public class InterfaceTest &#123;
    public static void main(String[] args) &#123;
        
        ComparableCircle c1 = new ComparableCircle(3.4);
        ComparableCircle c2 = new ComparableCircle(3.6);
        
        int compareValue = c1.compareTo(c2);
        if(compareValue &gt; 0)&#123;
            System.out.println(&quot;c1 对象大&quot;);
        &#125;else if(compareValue &lt; 0)&#123;
            System.out.println(&quot;c2 对象大&quot;);
        &#125;else&#123;
            System.out.println(&quot;两个一样的&quot;);
        &#125;
        
        int compareValue1 = c1.compareTo(new String(&quot;AA&quot;));
        System.out.println(compareValue1);
    &#125;
&#125;
</code></pre>
<h2 id="18-类的内部成员之五：内部类"><a href="#18-类的内部成员之五：内部类" class="headerlink" title="18.类的内部成员之五：内部类"></a>18.类的内部成员之五：内部类</h2><pre><code class="Java">/*
 * 类的内部成员之五:内部类
 * 
 * 1.Java中允许将一个类A声明在另一个类B中,则类A就是内部类,类B就是外部类.
 * 
 * 2.内部类的分类:成员内部类	VS	局部内部类(方法内、代码块内、构造器内)
 * 		
 * 3.成员内部类
 * 	》作为外部类的成员,
 * 		- 调用外部类的结构
 * 		- 可以被static修饰
 * 		- 可以被4种不同的权限修饰
 * 
 *  》作为一个类，
 *  	- 类内可以定义属性、方法、构造器等
 *  	- 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
 *  	- 可以abstract修饰
 * 
 * 4.关注如下的3个问题
 *   》 如何实例化成员内部类的对象
 *   》 如何在成员内部类中区分调用外部类的结构
 *   》 开发中局部内部类的使用  见《InnerClassTest1.java》
 */
public class InnerClassTest &#123;
    public static void main(String[] args) &#123;
        
        //创建Dog实例(静态的成员内部类)
        Person.Dog dog = new Person.Dog();
        dog.show();
        
        //创建Bird实例(非静态的成员内部类)
//		Person.Bird bird = new Person.Bird();
        Person p = new Person();
        Person.Bird bird = p.new Bird();
        bird.sing();
        
        System.out.println();
        
        bird.display(&quot;喜鹊&quot;);
    &#125;
&#125;
class Person&#123;
    String name = &quot;李雷&quot;;
    int age;
    
    public void eat()&#123;
        System.out.println(&quot;人，吃饭&quot;);
    &#125;
    
    //静态成员内部类
    static class Dog&#123;
        String name;
        int age;
        
        public void show()&#123;
            System.out.println(&quot;卡拉是条狗&quot;);
//			eat();
        &#125;
    &#125;
    
    //非静态成员内部类
    class Bird&#123;
        String name = &quot;杜鹃&quot;;
        public Bird()&#123;
            
        &#125;
        
        public void sing()&#123;
            System.out.println(&quot;我是一只猫头鹰&quot;);
            Person.this.eat();//调用外部类的非静态属性
            eat();
            System.out.println(age);
        &#125;
        
        public void display(String name)&#123;
            System.out.println(name);	//方法的形参
            System.out.println(this.name);	//内部类的属性
            System.out.println(Person.this.name);	//外部类的属性
        &#125;
    &#125;
    public void method()&#123;
        //局部内部类
        class AA&#123;
            
        &#125;
    &#125;
    
    &#123;
        //局部内部类
        class BB&#123;
            
        &#125;
    &#125;
    
    public Person()&#123;
        //局部内部类
        class CC&#123;
            
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>面向对象学习的过程算是比较久，断断续续，希望后面有时间把这部分知识在复习一遍。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
