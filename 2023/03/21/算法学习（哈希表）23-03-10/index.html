<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>算法练习（哈希表） | 方立夏</title>
  <meta name="keywords" content=" java , Github ">
  <meta name="description" content="算法练习（哈希表） | 方立夏">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="算法学习（2023 -03-09）（数组）涉及到的算法题目1.2.3题涉及的知识点为滑动窗口1.长度最小的子数组1.题目给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 解释：子数组 [">
<meta property="og:type" content="article">
<meta property="og:title" content="算法练习（数组滑动窗口）">
<meta property="og:url" content="http://example.com/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A03%EF%BC%88%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%9A%84%E5%89%A9%E4%BD%99%E7%9F%A5%E8%AF%86%EF%BC%89/index.html">
<meta property="og:site_name" content="方立夏">
<meta property="og:description" content="算法学习（2023 -03-09）（数组）涉及到的算法题目1.2.3题涉及的知识点为滑动窗口1.长度最小的子数组1.题目给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出：2 解释：子数组 [">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210312160441942.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCicvQicWSnN5ZNP97xQibk5RenSvNNZpr8ibMzLDeC2apV3ia2XS7ibTLC5WgGn3VStmCTw6elicia0ht2v6g/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBCcaan5hg7GsqSCVwq4sgZHyqBqfFF4G4oTjhACibCp2RcuMEPeHVjKQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBRn0NZibJkWiaJ522aMDOQEsiaiaX4AuXIBEjjKqetvibL104qGfSvmU4BRg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBECDRbicfLRcRFCERDN4Ykq56ILvDlh6bft5nzG5TqgFXw4ib4y4kw4OA/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBcBzAWFuJjRttCghicyKua5cXicG1db1nTj3QLUh4nXgBNVkp2gznOzdw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBHI2kPictZLyUeWXQ9Q6N5WBzRlBEXLRewuCDnmL4F2YiaPDN20w2ib9OQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBvib02FtjqhSI1R4CQVan160CwemYBsuofXycNecXWJIdysfwBeL2HibQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBbdTCtSzibQCt2O6kXkY18e5cncbriaPmjVDia5jp7rgFXICOoQPLBRIDA/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBS9aOEoYGMaic9SBZ2RoRx7soNExMKFbP3NsVo7aicKBjqz0iae46vATRg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBGttfPK4icjwqxIOHdXC0xoMBLsG173oEN1KTlCmxGvN360XPiciaqvzIg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBGAM79Tu8Xz5PX4C7Ub0oYFfUiaWU9qnrAXBmJZWPM8gGCloPaUqBwicQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBWDzzNiamIibl3YACnJyz1mgAnHwuTcteHOXpIXO5icph9rQAMxWTg4e7A/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBfwZocA61fXZPC26uuNKMUsk062VgbicxcLibf5tTQt2Uf6seEBYuZNlQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBtxrnKCicDoKEz5KvUAp4YIzA0W9d66xLK3z1HCpoVD5n1cXJUEnLvvQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBUQlq7WcBBpNfnz7OhuFtl72dMsNHstTiaD1icZCMO7ibFoxfkRun7aorg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBwoNdbBfnQbibPDibLpmyCKZ5XIpzUbjtgDaR86xUBFWDFGTgKPibGZcjw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSB5q9L67xuHKkWq8aGMsAOGty4Eybu1wicNicQmiajtCplAPNzxHicQggnyw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6b0Ce5EY0oeQpcNQsMsxSBfMaWjJSOIdunBicib5lB9TImdvGUgJQoibouvvl7dIRIL6CztXY0tBDoQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png">
<meta property="article:published_time" content="2023-03-21T07:31:11.887Z">
<meta property="article:modified_time" content="2023-03-21T07:28:51.314Z">
<meta property="article:author" content="方立夏">
<meta property="article:tag" content="java">
<meta property="article:tag" content="Github">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/github.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>方立夏</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/fanglixia666"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:2377579176@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2377579176&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(9)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="博客篇">
                        
                        博客篇
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="后端篇">
                        
                        后端篇
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法篇">
                        
                        算法篇
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="9">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Github</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A03%EF%BC%88%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E7%9A%84%E5%89%A9%E4%BD%99%E7%9F%A5%E8%AF%86%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（数组滑动窗口）">算法练习（数组滑动窗口）</span>
            <span class="post-date" title="2023-03-21 15:31:11">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（数组）">算法练习（数组）</span>
            <span class="post-date" title="2023-03-21 15:31:10">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8923-03-10/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（哈希表）">算法练习（哈希表）</span>
            <span class="post-date" title="2023-03-21 15:31:08">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 后端篇 "
           href="/2023/03/21/Java%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%B1%BB%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="面向对象（类与对象）">面向对象（类与对象）</span>
            <span class="post-date" title="2023-03-21 15:30:59">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 后端篇 "
           href="/2023/03/21/Java%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%8C%20%E6%B3%9B%E6%80%A7%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="面向对象（类与对象）">面向对象（类与对象）</span>
            <span class="post-date" title="2023-03-21 15:30:57">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A02%E4%B8%80%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（双指针）">算法练习（双指针）</span>
            <span class="post-date" title="2023-03-21 15:25:32">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 算法篇 "
           href="/2023/03/21/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"
           data-tag="java,Github"
           data-author="" >
            <span class="post-title" title="算法练习（字符串）">算法练习（字符串）</span>
            <span class="post-date" title="2023-03-21 15:25:25">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 博客篇 "
           href="/2023/03/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/"
           data-tag="Github,Hexo"
           data-author="" >
            <span class="post-title" title="11月Java总结">11月Java总结</span>
            <span class="post-date" title="2023-03-21 10:56:25">2023/03/21</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/03/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-03-21 10:51:18">2023/03/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-算法学习（哈希表）23-03-10" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">算法练习（哈希表）</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法篇">算法篇</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">java</a>
            
            <a class="color2">Github</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-03-21 15:29:17'>2023-03-21 15:31</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8923-03-10"><span class="toc-text">算法学习（哈希表）23-03-10</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-text">涉及的算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">1.242.有效的字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-text">2.赎金信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF"><span class="toc-text">2.思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="toc-text">1.暴力解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E8%A7%A3%E6%B3%95"><span class="toc-text">2.哈希解法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-%E5%93%88%E5%B8%8C%E8%A7%A3%E6%B3%95"><span class="toc-text">3.代码实现(哈希解法)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-49%EF%BC%9A%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">3.49：字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-1"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF-1"><span class="toc-text">2.思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">3.实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-438%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">4.438找到字符串中所有字母异位词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-2"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8A%A0%E4%B8%8A%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-text">2.思路（滑动窗口加上哈希表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-1"><span class="toc-text">3.实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-349%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%EF%BC%88%E7%94%A8set%E6%9D%A5%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-text">5.349两个数组的交集（用set来解决）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-3"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF-2"><span class="toc-text">2.思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9A%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%8F%AF%E5%BE%97"><span class="toc-text">问题1：从题目可得</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%982%EF%BC%9B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%81%9A%E8%BF%99%E4%B8%80%E9%81%93%E9%A2%98"><span class="toc-text">问题2；为什么不用数组来做这一道题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%983%EF%BC%9A%E9%82%A3%E5%8F%AA%E8%A6%81%E6%98%AF%E5%93%88%E5%B8%8C%E9%97%AE%E9%A2%98%EF%BC%8C%E6%88%91%E5%B0%B1%E9%83%BD%E6%9C%89set%E8%A7%A3%E5%86%B3%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="toc-text">问题3：那只要是哈希问题，我就都有set解决可以吗</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-2"><span class="toc-text">3.实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II-%E4%BB%8Emap%E6%96%B9%E6%B3%95%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%A4%E4%B8%AA%E6%96%B9%E9%9D%A2%E5%8E%BB%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-text">6.350.两个数组的交集 II(从map方法与双指针两个方面去解决问题)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE%C2%B7"><span class="toc-text">1.题目·</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-3"><span class="toc-text">3.实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-text">7.快乐数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-4"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF-3"><span class="toc-text">2.思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%BB%8E%E8%BF%99%E9%81%93%E9%A2%98%E8%A1%8D%E7%94%9F%E5%87%BA%E7%9A%84%E4%B8%80%E7%B1%BB%E9%97%AE%E9%A2%98%E9%83%BD%E7%94%A8map%E6%9D%A5%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-text">8.两数之和（从这道题衍生出的一类问题都用map来解决）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-5"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF-4"><span class="toc-text">2.思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-text">1.第一点，为什么使用哈希法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E7%82%B9%E8%A6%81%E7%94%A8map%EF%BC%8C%E4%B8%8D%E7%94%A8%E6%95%B0%E7%BB%84%E8%B7%9Fset"><span class="toc-text">2.第二点要用map，不用数组跟set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%A2%98%E7%9B%AE%E4%B8%AD%E7%9A%84map%E7%9A%84key%E5%92%8Cvalue%E5%88%86%E5%88%AB%E6%9D%A5%E5%AD%98%E4%BB%80%E4%B9%88"><span class="toc-text">3.题目中的map的key和value分别来存什么</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-4"><span class="toc-text">3.实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E8%BF%99%E9%81%93%E9%A2%98%E5%BC%80%E5%A7%8B%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B8%80%E4%BA%9B%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C%EF%BC%89%EF%BC%88%E8%BF%99%E9%81%93%E9%A2%98%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%96%B9%E6%B3%95%E6%AF%94%E5%93%88%E5%B8%8C%E6%B3%95%E5%A5%BD%EF%BC%89"><span class="toc-text">9.三数之和（这道题开始涉及到一些去重操作）（这道题用双指针方法比哈希法好）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-6"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF-5"><span class="toc-text">2.思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%BA%E4%BD%95%E5%93%88%E5%B8%8C%E4%B8%8D%E9%80%82%E7%94%A8"><span class="toc-text">1.为何哈希不适用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">2.双指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8E%BB%E9%87%8D%E9%80%BB%E8%BE%91%E4%B8%8E%E5%89%AA%E6%9E%9D"><span class="toc-text">3.去重逻辑与剪枝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-5"><span class="toc-text">3.实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">10.四数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-7"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF-6"><span class="toc-text">2.思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-6"><span class="toc-text">3.实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II"><span class="toc-text">11.四数相加II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%98%E7%9B%AE-8"><span class="toc-text">1.题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%80%9D%E8%B7%AF-7"><span class="toc-text">2.思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-7"><span class="toc-text">3.实现代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="算法学习（哈希表）23-03-10"><a href="#算法学习（哈希表）23-03-10" class="headerlink" title="算法学习（哈希表）23-03-10"></a>算法学习（哈希表）23-03-10</h1><h2 id="涉及的算法题"><a href="#涉及的算法题" class="headerlink" title="涉及的算法题"></a>涉及的算法题</h2><h3 id="1-242-有效的字母异位词"><a href="#1-242-有效的字母异位词" class="headerlink" title="1.242.有效的字母异位词"></a>1.242.有效的字母异位词</h3><p>1.题目</p>
<p>2.思路</p>
<p>3.实现代码</p>
<pre><code class="java">class Solution &#123;
public boolean isAnagram(String s, String t) &#123;
    int[] record = new int[26];
    for(int i=0;i&lt;s.length();i++) &#123;
        record[s.charAt(i)-&#39;a&#39;]++;// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
        &#125;
    &#125;
    for(int i=0;i&lt;t.length();i++) &#123;
        record[t.charAt(i) - &#39;a&#39;]--;
    &#125;
    for(int count:record) &#123;
        if(count!=0)&#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
&#125;
</code></pre>
<h3 id="2-赎金信"><a href="#2-赎金信" class="headerlink" title="2.赎金信"></a>2.赎金信</h3><h4 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h4><h4 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h4><h5 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1.暴力解法"></a>1.暴力解法</h5><p>运用两个for进行循环，找到目标元素</p>
<pre><code class="java">class solution&#123;
public void bool canConstruct(string ransomNote, string magazine) &#123;
    for(int i=0;i&lt;magazine.length();i++) &#123;
        for(int j= 0;j&lt;ransonNote.length();j++) &#123;
        if(magazine[i] == ransonNote[j]) &#123;
            ransomNote.erase(ransomNote.begin()+j);
            break;
        &#125;
        &#125;
    &#125;
    if(ransonNote.length()==0) &#123;
        return true;
    &#125;
    return false;
&#125;
&#125;
</code></pre>
<h5 id="2-哈希解法"><a href="#2-哈希解法" class="headerlink" title="2.哈希解法"></a>2.哈希解法</h5><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。</p>
<p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p>
<p>依然是数组在哈希法中的应用。</p>
<p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p>
<h4 id="3-代码实现-哈希解法"><a href="#3-代码实现-哈希解法" class="headerlink" title="3.代码实现(哈希解法)"></a>3.代码实现(哈希解法)</h4><pre><code class="java">class Solution &#123;
    public boolean canConstruct(String ransomNote, String magazine) &#123;
        int[] record = new int[26];
        for(char c:magazine.toCharArray()) &#123;
            record[c-&#39;a&#39;]+=1;
        &#125;
        for(char c:ransonNote.toCharArray()) &#123;
            record[c-&#39;a&#39;]-=1;
        &#125;
        for(int i:record) &#123;
            if(i&lt;0) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h3 id="3-49：字母异位词分组"><a href="#3-49：字母异位词分组" class="headerlink" title="3.49：字母异位词分组"></a>3.49：字母异位词分组</h3><h4 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1.题目"></a>1.题目</h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>举个例子，比如给定的数组是[eat, ate, tea, tan, nat, bat]。其中eat，ate，tea这三个单词用到的字母都是e，t和a各一个。tan和nat用到的都是a，n和t，最后剩下bat，所以分组结果就是：[eat, ate, tea]，[tan, nat]和[bat]。</p>
<h4 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2.思路"></a>2.思路</h4><p>两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p>
<p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p>
<p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p>
<p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。</p>
<h4 id="3-实现代码"><a href="#3-实现代码" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><pre><code class="Java">
public class Solution &#123;
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;
        Set set = new HashSet&lt;&gt;();
        HashMap&lt;Map,List&lt;String&gt;&gt; map = new HashMap();
        for(int i=0;i&lt;strs.length;i++) &#123;
            String str = strs[i];
            Map&lt;Character,Integer&gt; wordcount = new HashMap&lt;&gt;();
            for(int j=0;j&lt;str.length;i++) &#123;
                char c=str.charAt(j);
                int cnt = wordcount.getOrDefault(c,0);
                wordcount.put(c.cnt+1);
            &#125;
            List&lt;String&gt; list = (List&lt;String&gt;) map.getOrDefault(worldCount,new ArrayList&lt;String&gt; ());
            list.add(str);
            map.put(wordCount,list);
        &#125;
        List&lt;List&lt;String&gt;&gt; rs = new ArrayList&lt;&gt;();
        for(List&lt;String&gt; List:map.value()) &#123;
            rs.add(list);
        &#125;
        return rs;
    &#125;
&#125;
</code></pre>
<p>第二种代码实现方式</p>
<pre><code class="Java">
class Solution &#123;
    //key - sorted String[i], value - String[i] list
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;
        Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
        for (String s : strs)&#123;
            //将key排序
            char[] charArray = s.toCharArray();
            Arrays.sort(charArray);
            String temp = String.valueOf(charArray);
            if (map.containsKey(temp))&#123;
                List&lt;String&gt; list = map.get(temp);
                list.add(s);
                map.put(temp, list);
            &#125;else &#123;
                List&lt;String&gt; list = new ArrayList&lt;&gt;();
                list.add(s);
                map.put(temp, list);
            &#125;
        &#125;
        List&lt;List&lt;String&gt;&gt; list = new LinkedList&lt;&gt;();
        for (String key : map.keySet())&#123;
            list.add(map.get(key));
        &#125;
        return list;
    &#125;
&#125;
</code></pre>
<h3 id="4-438找到字符串中所有字母异位词"><a href="#4-438找到字符串中所有字母异位词" class="headerlink" title="4.438找到字符串中所有字母异位词"></a>4.438<strong>找到字符串中所有字母异位词</strong></h3><h4 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1.题目"></a>1.题目</h4><p>第438题：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<p><strong>字母异位词指字母相同，但排列不同的字符串。</strong></p>
<p>不考虑答案输出的顺序。</p>
<p>示例 1:</p>
<p>输入:</p>
<p>s: “cbaebabacd” p: “abc”</p>
<p>输出:</p>
<p>[0, 6]</p>
<p>解释:</p>
<p>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。</p>
<p>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。</p>
<p>示例 2:</p>
<p>输入:</p>
<p>s: “abab” p: “ab”</p>
<p>输出:</p>
<p>[0, 1, 2]</p>
<p>解释:</p>
<p>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。</p>
<p>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。</p>
<p>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p>
<h4 id="2-思路（滑动窗口加上哈希表）"><a href="#2-思路（滑动窗口加上哈希表）" class="headerlink" title="2.思路（滑动窗口加上哈希表）"></a>2.思路（滑动窗口加上哈希表）</h4><p>直接套用之前的模式，使用双指针来模拟一个滑动窗口进行解题。分析过程如下：</p>
<p>假设我们有字符串为“cbaebabacd”，目标串为“abc”</p>
<p>我们通过双指针维护一个窗口，由于我们只需要判断字母异位词，我们可以将窗口初始化大小和目标串保持一致。（当然，你也可以初始化窗口为1，逐步扩大）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/cXoa07I9qrlXdfHLHcVjNHPmexJn8sGicJ5zrPb9UoWxWo158lUMTIdCZHy8ibibUoU8ySw6NOAWEU8ayibicCzPN2g/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而<strong>判断字母异位词</strong>，我们需要<strong>保证窗口中的字母出现次数与目标串中的字母出现次数一致</strong>。这里因为字母只有26个，直接使用数组来替代map进行存储（和上一讲中的ASCII使用256数组存储思想一致）。</p>
<p>pArr为目标串数组，sArr为窗口数组。我们发现初始化数组，本身就满足，记录下来。（<strong>这里图示用map模拟数组，便于理解</strong>）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/cXoa07I9qrlXdfHLHcVjNHPmexJn8sGiccSj1SagTT48sQRG4YuCx26JbC6cR2dsTVFCtaXYa60E1tCGqFVrhUA/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后我们通过移动窗口，来更新窗口数组，进而和目标数组匹配，匹配成功进行记录。每一次窗口移动，<strong>左指针前移</strong>，原来<strong>左指针位置处的数值减1，表示字母移出</strong>；<strong>同时右指针前移</strong>，<strong>右指针位置处的数值加1，表示字母移入</strong>。详细过程如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/cXoa07I9qrlXdfHLHcVjNHPmexJn8sGicEkTBAsM1KGicK4cQ4v3EgLpGa1pgOtjzZt3wJvXNgOZHCElpOyuPUcQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/cXoa07I9qrlXdfHLHcVjNHPmexJn8sGictUBAsGiabNVYibDPahIH9WjHtBFJnphicrkvRLHscrX0dchKm830oPv1A/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>最终，当右指针到达边界，意味着匹配完成。</p>
<h4 id="3-实现代码-1"><a href="#3-实现代码-1" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><pre><code class="Java">class Solution &#123;
     public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;
        if (s==null ||p==null||s.length() &lt;p.length()) return new ArrayList&lt;&gt;();
         List&lt;Integer&gt; List = new ArrayList&lt;&gt;();
         int[] parr = new int[26];
         int[] sarr = new int[26];
         int m = s.length();
         int n = p.length();
         
         for(int i=0;i&lt;p.length();i++) &#123;
             sarr[s.charAt(i) - &#39;a&#39;]++;
             parr[p.charAt(i) - &#39;a&#39;]++;
         &#125;
         if(Array.equals(sarr,parr)) &#123;
             List.add(0);
         &#125;
         for(int i=0;i&lt;m-n;i++) &#123;
             parr[s.charAt(i) - &#39;a&#39;]--;
             sarr[s.charAt(i+n) - &#39;a&#39;]++;
         &#125;
         if(Array.equals(sarr,parr)) &#123;
             List.add(i+1);
         &#125;
     &#125;
    return List;
&#125;
</code></pre>
<h3 id="5-349两个数组的交集（用set来解决）"><a href="#5-349两个数组的交集（用set来解决）" class="headerlink" title="5.349两个数组的交集（用set来解决）"></a>5.349两个数组的交集（用set来解决）</h3><h4 id="1-题目-3"><a href="#1-题目-3" class="headerlink" title="1.题目"></a>1.题目</h4><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200818193523911.png" alt="349. 两个数组的交集"></p>
<p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p>
<h4 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2.思路"></a>2.思路</h4><h5 id="问题1：从题目可得"><a href="#问题1：从题目可得" class="headerlink" title="问题1：从题目可得"></a>问题1：从题目可得</h5><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序</strong></p>
<h5 id="问题2；为什么不用数组来做这一道题"><a href="#问题2；为什么不用数组来做这一道题" class="headerlink" title="问题2；为什么不用数组来做这一道题"></a>问题2；为什么不用数组来做这一道题</h5><p>那么用数组来做哈希表也是不错的选择，例如<a target="_blank" rel="noopener" href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词(opens new window)</a></p>
<p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p>
<p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p>
<p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p>
<p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p>
<h5 id="问题3：那只要是哈希问题，我就都有set解决可以吗"><a href="#问题3：那只要是哈希问题，我就都有set解决可以吗" class="headerlink" title="问题3：那只要是哈希问题，我就都有set解决可以吗"></a>问题3：那只要是哈希问题，我就都有set解决可以吗</h5><p>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。</p>
<p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的</p>
<h4 id="3-实现代码-2"><a href="#3-实现代码-2" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><pre><code class="Java">import java.util.HashSet;
import java.util.Set;

class Solution &#123;
    public int[] intersection(int[] nums1, int[] nums2) &#123;
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) &#123;
            return new int[0];
        &#125;
        Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;();;
        Set&lt;Integet&gt; reset = new KashSet&lt;&gt;
           for(int i：nums1) &#123;
               set1.add(i);
               
           &#125;
        for(int i:nums2) &#123;
            if(set1.contains(i)) &#123;
                reset.add(i)
            &#125;
        &#125;
       int[] arr = new int[resrt.size()];
        int j=0;
        for(int i:reset) &#123;
            arr[j++] = i;
        &#125;
        return arr;
   &#125;
&#125;
</code></pre>
<h3 id="6-350-两个数组的交集-II-从map方法与双指针两个方面去解决问题"><a href="#6-350-两个数组的交集-II-从map方法与双指针两个方面去解决问题" class="headerlink" title="6.350.两个数组的交集 II(从map方法与双指针两个方面去解决问题)"></a>6.350.两个数组的交集 II(从map方法与双指针两个方面去解决问题)</h3><h4 id="1-题目·"><a href="#1-题目·" class="headerlink" title="1.题目·"></a>1.题目·</h4><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1:</p>
<p>输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2] 输出: [2,2] 示例 2:</p>
<p>输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4] 输出: [4,9] 说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。进阶:</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p>
<p>2.思路</p>
<h4 id="3-实现代码-3"><a href="#3-实现代码-3" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><p>1.map方法</p>
<p>Map计数法：使用map结构计数较短数组中元素的个数，遍历长数组，从map中查找到对应数值后，计数减一，并存储结果，最后返回；</p>
<pre><code class="Java">
public int[] intersect(int[] nums1, int[] nums2) &#123;
    if (nums1.length &gt; nums2.length) &#123;
        return intersect(nums2, nums1);
    &#125;
    Map&lt;Integer, Integer&gt; nums1CountMap = new HashMap&lt;&gt;(nums1.length);
    for(int i:nums1)&#123;
      nums1CountMap.put(i,nums1CountMap.getOrDefault(i,0)+1);  
    &#125;
    int k=0;
    for(int i :nums2) &#123;
        if(nums1CountMap.containKey(i)) &#123;
            nums1[k++] =i;
            nums1CountMap.put(i,nums1CountMap,get(i)-1);
            //移除以及没有的字母后再输出
            if(nums1CountMap.get(i) == 0)&#123;
                nums1CountMap.remove(i);
            &#125;
        &#125;
    &#125;
    return Arrays.copyOfRange(nums1,0,k);
&#125;
</code></pre>
<p>2.双指针法</p>
<ol>
<li>双指针法：将两个数组参数先进性排序，然后使用双指针同时遍历两个数组，较小元素所在数组指针进行后移，相等元素则加入结果，最后返回结束。这里可以使用将结果存储于较短数组参数中，使用第三个指针，指定的当前结果存储的位置。</li>
</ol>
<pre><code class="Java">
public int[] intersect(int[] nums1, int[] nums2) &#123;
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int i = 0, j = 0, k = 0;
    while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;
        if (nums1[i] &lt; nums2[j]) &#123;
            i++;
        &#125; else if (nums1[i] &gt; nums2[j]) &#123;
            j++;
        &#125; else &#123;
            nums1[k++] = nums1[i];
            i++;
            j++;
        &#125;
    &#125;
    return Arrays.copyOfRange(nums1, 0, k);
&#125;
</code></pre>
<h3 id="7-快乐数"><a href="#7-快乐数" class="headerlink" title="7.快乐数"></a>7.快乐数</h3><h4 id="1-题目-4"><a href="#1-题目-4" class="headerlink" title="1.题目"></a>1.题目</h4><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p><strong>示例：</strong></p>
<p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</p>
<h4 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2.思路"></a>2.思路</h4><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p>
<p>正如：<a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！ (opens new window)</a>中所说，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p>
<p>所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<p>判断sum是否重复出现就可以使用unordered_set。</p>
<p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p>
<h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><pre><code class="java">class Solution &#123;
    public boolean isHappy(int n) &#123;
    Set&lt;Integer&gt; record = new HashSet&lt;&gt;();
        //判断是否会出现相等的数，如果有相等的数，则退出循环，因为已经不可能了
    while(n !=1 &amp;&amp; !record.contains(n)) &#123;
        record.add(n);
        n=getNextNumber(n);
    &#125;
        return n==1;
    &#125;
    private int getNextNumber(int n) &#123;
        int res = 0;
        while(n&gt;0)&#123;
            int temp = n%10;
            res+=temp*temp;
            n = n/10;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h3 id="8-两数之和（从这道题衍生出的一类问题都用map来解决）"><a href="#8-两数之和（从这道题衍生出的一类问题都用map来解决）" class="headerlink" title="8.两数之和（从这道题衍生出的一类问题都用map来解决）"></a>8.两数之和（从这道题衍生出的一类问题都用map来解决）</h3><h4 id="1-题目-5"><a href="#1-题目-5" class="headerlink" title="1.题目"></a>1.题目</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p>
<p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p>
<p>所以返回 [0, 1]</p>
<h4 id="2-思路-4"><a href="#2-思路-4" class="headerlink" title="2.思路"></a>2.思路</h4><h5 id="1-第一点，为什么使用哈希法"><a href="#1-第一点，为什么使用哈希法" class="headerlink" title="1.第一点，为什么使用哈希法"></a>1.第一点，为什么使用哈希法</h5><p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p>
<p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p>
<p>那么我们就应该想到使用哈希法了。</p>
<h5 id="2-第二点要用map，不用数组跟set"><a href="#2-第二点要用map，不用数组跟set" class="headerlink" title="2.第二点要用map，不用数组跟set"></a>2.第二点要用map，不用数组跟set</h5><p>因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p>再来看一下使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。</p>
<p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong></p>
<h5 id="3-题目中的map的key和value分别来存什么"><a href="#3-题目中的map的key和value分别来存什么" class="headerlink" title="3.题目中的map的key和value分别来存什么"></a>3.题目中的map的key和value分别来存什么</h5><p>map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p>
<p>接下来是map中key和value分别表示什么。</p>
<p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p>
<p>那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。</p>
<p>所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p>
<p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p>
<p>过程如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png" alt="过程二"></p>
<h4 id="3-实现代码-4"><a href="#3-实现代码-4" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><pre><code class="Java">public int[] twoSum(int[] nums, int target) &#123;
    int[] res = new int[2];
    if(nums == null || nums.length == 0) &#123;
        return res;
    &#125;
    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
    for(int i=0;i&lt;nums.length;i++) &#123;
        int temp = target-nums[i]; // 遍历当前元素，并在map中寻找是否有匹配的key
        if(map.containsKey(temp)) &#123;
            res[1] = i;
            res[0] = map.get(temp);
            break;
        &#125;
        map.put(nums[i],i);  // 如果没找到匹配对，就把访问过的元素和下标加入到map中
    &#125;
    &#125;
    return res;
&#125;
</code></pre>
<h3 id="9-三数之和（这道题开始涉及到一些去重操作）（这道题用双指针方法比哈希法好）"><a href="#9-三数之和（这道题开始涉及到一些去重操作）（这道题用双指针方法比哈希法好）" class="headerlink" title="9.三数之和（这道题开始涉及到一些去重操作）（这道题用双指针方法比哈希法好）"></a>9.三数之和（这道题开始涉及到一些去重操作）（这道题用双指针方法比哈希法好）</h3><h4 id="1-题目-6"><a href="#1-题目-6" class="headerlink" title="1.题目"></a>1.题目</h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<p>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h4 id="2-思路-5"><a href="#2-思路-5" class="headerlink" title="2.思路"></a>2.思路</h4><h5 id="1-为何哈希不适用"><a href="#1-为何哈希不适用" class="headerlink" title="1.为何哈希不适用"></a>1.为何哈希不适用</h5><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。</p>
<p>把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。</p>
<p>去重的过程不好处理，有很多小细节，如果在面试中很难想到位。</p>
<p>时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。</p>
<p>大家可以尝试使用哈希法写一写，就知道其困难的程度了。</p>
<h5 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2.双指针"></a>2.双指针</h5><p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p>
<p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p>
<p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p>
<h5 id="3-去重逻辑与剪枝"><a href="#3-去重逻辑与剪枝" class="headerlink" title="3.去重逻辑与剪枝"></a>3.去重逻辑与剪枝</h5><p>1.a的去重</p>
<p>说道去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</p>
<p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p>
<p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p>
<p>有同学可能想，这不都一样吗。</p>
<p>其实不一样！</p>
<p>都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。</p>
<p>如果我们的写法是 这样：</p>
<pre><code class="java">if (nums[i] == nums[i + 1]) &#123; // 去重操作
    continue;
&#125;
</code></pre>
<p>那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p>
<p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p>
<p>所以这里是有两个重复的维度。</p>
<p>那么应该这么写：</p>
<pre><code class="java">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;
    continue;
&#125;
</code></pre>
<p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p>
<p>这是一个非常细节的思考过程。</p>
<p>2.bc的去重 eg（0，-1，-1，-1，-1，-1，2，2，2，2，2）</p>
<p>很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）</p>
<pre><code class="text">while (right &gt; left) &#123;
    if (nums[i] + nums[left] + nums[right] &gt; 0) &#123;
        right--;
        // 去重 right
        while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;
    &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123;
        left++;
        // 去重 left
        while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;
    &#125; else &#123;
    &#125;
&#125;
</code></pre>
<p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p>
<p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right– 的操作。</p>
<p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p>
<p>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p>
<p>所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已。</p>
<p>3.剪枝 </p>
<p>每次进入for循环是，可以先对数据进行剪枝</p>
<h4 id="3-实现代码-5"><a href="#3-实现代码-5" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><pre><code class="Java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        Arrays.sort(nums);
        for(int i=0;i&lt;nums.length;i++) &#123;
            if(nums[i]&gt;0) &#123;
                return result;
            &#125;
            if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) &#123;
                continue;
            &#125;
            int left = i+1;
            int right = nums.length -1;
            while(right &gt;left) &#123;
                int sum = nums[i]+nums[left]+nums[right];
                if(sum &gt; 0)&#123;
                    right--;
                &#125;else if(sum &lt; 0) &#123;
                    left ++;
                &#125;else &#123;
                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(right &gt; left &amp;&amp; nums[right] == nums[right-1]) right--;
                      while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;
                    
                    right--; 
                    left++;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h3 id="10-四数之和"><a href="#10-四数之和" class="headerlink" title="10.四数之和"></a>10.四数之和</h3><h4 id="1-题目-7"><a href="#1-题目-7" class="headerlink" title="1.题目"></a>1.题目</h4><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例： 给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p>
<h4 id="2-思路-6"><a href="#2-思路-6" class="headerlink" title="2.思路"></a>2.思路</h4><p>四数之和，和<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>是一个思路，都是使用双指针法, 基本解法就是在<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>的基础上再套一层for循环。</p>
<p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] &#x3D;&#x3D; 0。</p>
<p>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</p>
<p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p>
<p>对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</p>
<p>之前我们讲过哈希表的经典题目：<a target="_blank" rel="noopener" href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html">454.四数相加II (opens new window)</a>，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。</p>
<h4 id="3-实现代码-6"><a href="#3-实现代码-6" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><pre><code class="Java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target)&#123;
       List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        Arrays.sort(nums);
        for(int i=0;i&lt;nums.length;i++) &#123;
            if(nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;
                return result;
            &#125;
            if(i&gt;0 &amp;&amp; nums[i-1] == nums[i]) &#123;
                continue;
            &#125;
            for(int j = i+1;j&lt;nums.length;j++) &#123;
                if(j&gt;i+1 &amp;&amp; nums[j-1] == nums[j]) &#123;
                    continue;
                &#125;
                int left = j+1;
                int right = nums.length -1;
                while (right &gt; left) &#123;
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
               if(sum&gt;target) &#123;
                   right--;
               &#125;else if(sum&lt;target) &#123;
                   left++;
               &#125;else &#123;
                   result.add(Arrays.aslist(nums[i],nums[j],nums[left],nums[right]));
                   while(right &gt; left &amp;&amp; nums[right] == nums[right -1]) right--;
                   while(right &gt; left &amp;&amp; nums[left] == nums[left+1] ) left++;
                   left ++;
                   right --;
               &#125;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h3 id="11-四数相加II"><a href="#11-四数相加II" class="headerlink" title="11.四数相加II"></a>11.四数相加II</h3><h4 id="1-题目-8"><a href="#1-题目-8" class="headerlink" title="1.题目"></a>1.题目</h4><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p>
<p><strong>例如:</strong></p>
<p>输入:</p>
<ul>
<li>A &#x3D; [ 1, 2]</li>
<li>B &#x3D; [-2,-1]</li>
<li>C &#x3D; [-1, 2]</li>
<li>D &#x3D; [ 0, 2]</li>
</ul>
<p>输出:</p>
<p>2</p>
<p><strong>解释:</strong></p>
<p>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li>
</ol>
<h4 id="2-思路-7"><a href="#2-思路-7" class="headerlink" title="2.思路"></a>2.思路</h4><p><strong>而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] &#x3D; 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！</strong></p>
<p>本题解题步骤：</p>
<ol>
<li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>
<li>定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>
<li>最后返回统计值 count 就可以了</li>
</ol>
<h4 id="3-实现代码-7"><a href="#3-实现代码-7" class="headerlink" title="3.实现代码"></a>3.实现代码</h4><pre><code class="java">class Solution &#123;
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt; ();
        int temp;
        int res = 0;
        for(int i : nums1) &#123;
            for(int j:nums2) &#123;
                if(map.containKey(temp))&#123;
                    map.put(temp,map.get(temp)+1);
                &#125;else &#123;
                    map.put(temp,1);
                &#125;
            &#125;
        &#125;
        for (int i : nums3) &#123;
            for (int j : nums4) &#123;
                temp = i + j;
                if (map.containsKey(0 - temp)) &#123;
                    res += map.get(0 - temp);
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1，2，3，4，题用数组来做哈希表</p>
<p>因为这道题目包含小写字母，那么使用数组来做哈希最合适不过。</p>
<p><strong>上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</strong></p>
<p>5.7.用set来做哈希表</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集 (opens new window)</a>中我们给出了什么时候用数组就不行了，需要用set。</p>
<p>这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p>
<p>主要原因有两个</p>
<ul>
<li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li>
<li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li>
</ul>
<p>所以此时一样的做映射的话，就可以使用set了。</p>
<p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希， 使用unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">202.快乐数 (opens new window)</a>中，我们再次使用了unordered_set来判断一个数是否重复出现过。</p>
<p>6.8.用map来做哈希表</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>中map正式登场。</p>
<p>来说一说：使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<p>map是一种<code>&lt;key, value&gt;</code>的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。</p>
<p>std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。</p>
<p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>中并不需要key有序，选择std::unordered_map 效率更高！</p>
<p>9，10哈希表不是很适合，使用双指针法做更高效</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
